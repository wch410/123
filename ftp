#!/bin/bash
set -e # Exit immediately if a command exits with a non-zero status.

# 脚本全局配置
SCRIPT_NAME="个人自用数据备份"
# 使用 XDG Base Directory Specification，将配置文件和日志文件放在标准位置
# 如果您不熟悉 XDG，可以继续使用 $HOME/.personal_backup_config
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/personal_backup"
LOG_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/personal_backup"
CONFIG_FILE="$CONFIG_DIR/config"
LOG_FILE="$LOG_DIR/log.txt"

# 默认值 (如果配置文件未找到)
declare -a BACKUP_SOURCE_PATHS_ARRAY=() # 要备份的源路径数组
BACKUP_SOURCE_PATHS_STRING="" # 用于配置文件保存的路径字符串，使用特殊分隔符连接

AUTO_BACKUP_INTERVAL_DAYS=7 # 默认自动备份间隔天数 (例如，7 天 = 1 周)
LAST_AUTO_BACKUP_TIMESTAMP=0 # 上次自动备份的 Unix 时间戳

# 备份保留策略默认值
RETENTION_POLICY_TYPE="none" # "none", "count", "days"
RETENTION_VALUE=0           # 要保留的备份数量或天数

# 云存储凭证变量 (现在从配置文件加载/保存，更方便)
S3_ACCESS_KEY=""
S3_SECRET_KEY=""
S3_ENDPOINT="" # Cloudflare R2 端点，例如："https://<ACCOUNT_ID>.r2.cloudflarestorage.com"
S3_BUCKET_NAME=""
S3_BACKUP_PATH="" # S3/R2 备份的目标路径

WEBDAV_URL=""
WEBDAV_USERNAME=""
WEBDAV_PASSWORD=""
WEBDAV_BACKUP_PATH="" # WebDAV 备份的目标路径

# --- [修改] FTP/FTPS/SFTP 凭证变量统一管理 ---
FTP_HOST=""
FTP_USERNAME=""
FTP_PASSWORD=""
FTP_PORT=21 # 默认 FTP 端口
FTP_BACKUP_PATH=""

FTPS_HOST=""
FTPS_USERNAME=""
FTPS_PASSWORD=""
FTPS_PORT=21 # 默认 FTPS 端口
FTPS_BACKUP_PATH=""

SFTP_HOST=""
SFTP_USERNAME=""
SFTP_PASSWORD="" # SFTP 建议使用 SSH 密钥，但这里也支持密码
SFTP_PORT=22 # 默认 SFTP 端口
SFTP_BACKUP_PATH=""

# 备份目标标志
BACKUP_TARGET_S3="false"      # 是否启用 S3/R2 备份 (true/false)
BACKUP_TARGET_WEBDAV="false" # 是否启用 WebDAV 备份 (true/false)
BACKUP_TARGET_FTP="false"     # 是否启用 FTP 备份 (true/false)
BACKUP_TARGET_FTPS="false"    # 是否启用 FTPS 备份 (true/false)
BACKUP_TARGET_SFTP="false"    # 是否启用 SFTP 备份 (true/false)

# Telegram 通知变量 (现在从配置文件加载/保存)
TELEGRAM_BOT_TOKEN=""
TELEGRAM_CHAT_ID=""

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # 无颜色 - 重置为默认终端颜色

# 用于存储临时压缩文件的目录，使用 mktemp 创建一个安全的临时目录
TEMP_DIR=""

# --- 辅助函数 ---

# 确保在脚本退出时清理临时目录
cleanup_temp_dir() {
    if [[ -n "$TEMP_DIR" && -d "$TEMP_DIR" ]]; then
        rm -rf "$TEMP_DIR"
        # 不使用 log_and_display，避免在退出时产生过多日志
        echo "$(date '+%Y-%m-%d %H:%M:%S') - 清理临时目录: $TEMP_DIR" >> "$LOG_FILE"
    fi
}

# 注册清理函数，以便在脚本退出时运行 (即使发生错误)
trap cleanup_temp_dir EXIT

# 清屏
clear_screen() {
    clear
}

# 显示脚本头部
display_header() {
    clear_screen
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${GREEN}      $SCRIPT_NAME      ${NC}"
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
}

# 显示消息并记录到日志
# 参数 1: 消息内容
# 参数 2: 颜色代码 (可选)
# 参数 3: 输出目的地 (可选，默认为 /dev/stdout。使用 /dev/stderr 将输出到标准错误)
log_and_display() {
    local message="$1"
    local color="$2"
    local output_destination="${3:-/dev/stdout}" # Default to stdout
    local plain_message
    # Strip ANSI escape codes from the message for logging
    plain_message=$(echo -e "$message" | sed 's/\x1b\[[0-9;]*m//g')

    # Log to file with timestamp
    echo "$(date '+%Y-%m-%d %H:%M:%S') - ${plain_message}" >> "$LOG_FILE"

    # Display to specified destination with optional color
    if [[ -n "$color" ]]; then
        echo -e "$color$message$NC" > "$output_destination"
    else
        echo -e "$message" > "$output_destination"
    fi
}

# 等待用户按 Enter 键继续
press_enter_to_continue() {
    echo ""
    log_and_display "${BLUE}按 Enter 键继续...${NC}" ""
    read -r
    clear_screen
}

# --- 配置保存和加载 ---

# 保存配置到文件
save_config() {
    # 确保配置目录存在
    mkdir -p "$CONFIG_DIR" 2>/dev/null
    if [ ! -d "$CONFIG_DIR" ]; then
        log_and_display "${RED}错误：无法创建配置目录 $CONFIG_DIR，请检查权限。${NC}"
        return 1
    fi

    # 将数组转换为字符串，使用 ;; 作为分隔符，确保路径中不太可能出现
    BACKUP_SOURCE_PATHS_STRING=$(IFS=';;'; echo "${BACKUP_SOURCE_PATHS_ARRAY[*]}")

    # 使用原子写入，避免部分写入导致文件损坏
    {
        echo "BACKUP_SOURCE_PATHS_STRING=\"$BACKUP_SOURCE_PATHS_STRING\"" # 保存路径字符串
        echo "AUTO_BACKUP_INTERVAL_DAYS=$AUTO_BACKUP_INTERVAL_DAYS"
        echo "LAST_AUTO_BACKUP_TIMESTAMP=$LAST_AUTO_BACKUP_TIMESTAMP"
        echo "RETENTION_POLICY_TYPE=\"$RETENTION_POLICY_TYPE\""
        echo "RETENTION_VALUE=$RETENTION_VALUE"

        # 保存敏感凭证
        echo "S3_ACCESS_KEY=\"$S3_ACCESS_KEY\""
        echo "S3_SECRET_KEY=\"$S3_SECRET_KEY\""
        echo "S3_ENDPOINT=\"$S3_ENDPOINT\""
        echo "S3_BUCKET_NAME=\"$S3_BUCKET_NAME\""
        echo "S3_BACKUP_PATH=\"$S3_BACKUP_PATH\"" # 保存 S3/R2 备份路径

        echo "WEBDAV_URL=\"$WEBDAV_URL\""
        echo "WEBDAV_USERNAME=\"$WEBDAV_USERNAME\""
        echo "WEBDAV_PASSWORD=\"$WEBDAV_PASSWORD\""
        echo "WEBDAV_BACKUP_PATH=\"$WEBDAV_BACKUP_PATH\"" # 保存 WebDAV 备份路径

        # --- [修改] FTP/FTPS/SFTP 配置保存 ---
        echo "FTP_HOST=\"$FTP_HOST\""
        echo "FTP_USERNAME=\"$FTP_USERNAME\""
        echo "FTP_PASSWORD=\"$FTP_PASSWORD\""
        echo "FTP_PORT=$FTP_PORT"
        echo "FTP_BACKUP_PATH=\"$FTP_BACKUP_PATH\""

        echo "FTPS_HOST=\"$FTPS_HOST\""
        echo "FTPS_USERNAME=\"$FTPS_USERNAME\""
        echo "FTPS_PASSWORD=\"$FTPS_PASSWORD\""
        echo "FTPS_PORT=$FTPS_PORT"
        echo "FTPS_BACKUP_PATH=\"$FTPS_BACKUP_PATH\""

        echo "SFTP_HOST=\"$SFTP_HOST\""
        echo "SFTP_USERNAME=\"$SFTP_USERNAME\""
        echo "SFTP_PASSWORD=\"$SFTP_PASSWORD\""
        echo "SFTP_PORT=$SFTP_PORT"
        echo "SFTP_BACKUP_PATH=\"$SFTP_BACKUP_PATH\""

        echo "BACKUP_TARGET_S3=\"$BACKUP_TARGET_S3\"" # 保存备份目标标志
        echo "BACKUP_TARGET_WEBDAV=\"$BACKUP_TARGET_WEBDAV\"" # 保存备份目标标志
        echo "BACKUP_TARGET_FTP=\"$BACKUP_TARGET_FTP\"" # 保存 FTP 备份目标标志
        echo "BACKUP_TARGET_FTPS=\"$BACKUP_TARGET_FTPS\"" # 保存 FTPS 备份目标标志
        echo "BACKUP_TARGET_SFTP=\"$BACKUP_TARGET_SFTP\"" # 保存 SFTP 备份目标标志

        echo "TELEGRAM_BOT_TOKEN=\"$TELEGRAM_BOT_TOKEN\""
        echo "TELEGRAM_CHAT_ID=\"$TELEGRAM_CHAT_ID\""
    } > "$CONFIG_FILE"

    log_and_display "配置已保存到 $CONFIG_FILE"
    # 重要：立即设置配置文件为安全权限
    chmod 600 "$CONFIG_FILE" 2>/dev/null # 抑制 chmod 失败时的错误 (例如，在只读文件系统上)
    log_and_display "${YELLOW}已将配置文件 $CONFIG_FILE 权限设置为 600 (只有所有者可读写)，请确保您的系统安全。${NC}"
}

# 从文件加载配置
load_config() {
    # 确保日志目录存在
    mkdir -p "$LOG_DIR" 2>/dev/null
    if [ ! -d "$LOG_DIR" ]; then
        echo "$(date '+%Y-%m-%d %H:%M:%S') - 错误：无法创建日志目录 $LOG_DIR，请检查权限。" | tee -a "$LOG_FILE"
        return 1
    fi

    if [[ -f "$CONFIG_FILE" ]]; then
        # 检查权限，如果不是 600，则发出警告并尝试设置
        current_perms=$(stat -c "%a" "$CONFIG_FILE" 2>/dev/null)
        if [[ "$current_perms" != "600" ]]; then
            log_and_display "${YELLOW}警告：配置文件 $CONFIG_FILE 权限不安全 (${current_perms})，建议设置为 600。正在尝试设置...${NC}"
            chmod 600 "$CONFIG_FILE" 2>/dev/null
            if [ $? -ne 0 ]; then
                log_and_display "${RED}错误：无法将配置文件 $CONFIG_FILE 权限设置为 600，请手动检查。${NC}"
            else
                log_and_display "${GREEN}已将配置文件 $CONFIG_FILE 权限设置为 600。${NC}"
            fi
        fi
        source "$CONFIG_FILE"
        log_and_display "配置已从 $CONFIG_FILE 加载。" "${BLUE}"

        # 将字符串解析回数组
        if [[ -n "$BACKUP_SOURCE_PATHS_STRING" ]]; then
            IFS=';;' read -r -a BACKUP_SOURCE_PATHS_ARRAY <<< "$BACKUP_SOURCE_PATHS_STRING"
        else
            BACKUP_SOURCE_PATHS_ARRAY=()
        fi
    else
        log_and_display "未找到配置文件 $CONFIG_FILE，将使用默认配置。首次运行或配置已被删除。" "${YELLOW}"
        # 确保新变量在未找到配置时也初始化为默认值
        BACKUP_SOURCE_PATHS_ARRAY=()
        BACKUP_SOURCE_PATHS_STRING=""
        S3_BACKUP_PATH=""
        WEBDAV_BACKUP_PATH=""
        FTP_BACKUP_PATH=""
        FTPS_BACKUP_PATH=""
        SFTP_BACKUP_PATH=""
        BACKUP_TARGET_S3="false"
        BACKUP_TARGET_WEBDAV="false"
        BACKUP_TARGET_FTP="false"
        BACKUP_TARGET_FTPS="false"
        BACKUP_TARGET_SFTP="false"
    fi
}

# --- 核心功能 ---

# [修改] 检查所需依赖项
check_dependencies() {
    local missing_deps=()
    command -v zip &> /dev/null || missing_deps+=("zip")
    # 检查 realpath 命令是否存在，用于规范化路径
    command -v realpath &> /dev/null || missing_deps+=("realpath")

    # 仅当 S3/R2 凭证在配置中设置时才检查 S3/R2 依赖项
    if [[ -n "$S3_ACCESS_KEY" && -n "$S3_SECRET_KEY" && -n "$S3_ENDPOINT" && -n "$S3_BUCKET_NAME" ]]; then
        # 优先检测 awscli，其次 s3cmd
        if ! (command -v aws &> /dev/null || command -v s3cmd &> /dev/null); then
            missing_deps+=("awscli 或 s3cmd (用于S3/R2)")
        fi
        command -v jq &> /dev/null || missing_deps+=("jq (用于S3/R2文件夹列表解析)") # S3/R2现在需要jq
    fi
    # 仅当 WebDAV 凭证在配置中设置时才检查 WebDAV 依赖项
    if [[ -n "$WEBDAV_URL" && -n "$WEBDAV_USERNAME" && -n "$WEBDAV_PASSWORD" ]]; then
        command -v curl &> /dev/null || missing_deps+=("curl (用于WebDAV)")
    fi
    
    # [修改] 统一检查 lftp，因为它现在处理 FTP, FTPS 和 SFTP
    if [[ -n "$FTP_HOST" && -n "$FTP_USERNAME" && -n "$FTP_PASSWORD" ]] || \
       [[ -n "$FTPS_HOST" && -n "$FTPS_USERNAME" && -n "$FTPS_PASSWORD" ]] || \
       [[ -n "$SFTP_HOST" && -n "$SFTP_USERNAME" && -n "$SFTP_PASSWORD" ]]; then
        command -v lftp &> /dev/null || missing_deps+=("lftp (用于FTP/FTPS/SFTP)")
    fi

    # 仅当 Telegram 凭证在配置中设置时才检查 curl 和 jq 依赖项
    if [[ -n "$TELEGRAM_BOT_TOKEN" && -n "$TELEGRAM_CHAT_ID" ]]; then
        command -v curl &> /dev/null || missing_deps+=("curl (用于Telegram)")
        command -v jq &> /dev/null || missing_deps+=("jq (用于Telegram消息URL编码)")
    fi

    if [ ${#missing_deps[@]} -gt 0 ]; then
        log_and_display "${RED}检测到以下依赖项缺失，请安装后重试：${missing_deps[*]}${NC}"
        log_and_display "例如 (Debian/Ubuntu): sudo apt update && sudo apt install zip awscli curl jq realpath lftp" "${YELLOW}"
        log_and_display "例如 (CentOS/RHEL): sudo yum install zip awscli curl jq realpath lftp" "${YELLOW}"
        press_enter_to_continue
        return 1
    fi
    return 0
}


# 发送 Telegram 消息的函数
# 参数 1: 消息内容
send_telegram_message() {
    local message_content="$1"
    if [[ -z "$TELEGRAM_BOT_TOKEN" || -z "$TELEGRAM_CHAT_ID" ]]; then
        log_and_display "${YELLOW}Telegram 通知未配置，跳过发送消息。${NC}" "" "/dev/stderr"
        return 1
    fi

    # 再次检查 curl 和 jq 是否存在
    if ! command -v curl &> /dev/null; then
        log_and_display "${RED}错误：发送 Telegram 消息需要 'curl' 命令，但未找到。${NC}" "" "/dev/stderr"
        return 1
    fi

    local encoded_message=""
    if command -v jq &> /dev/null; then
        encoded_message=$(printf %s "$message_content" | jq -sRr @uri)
    else
        log_and_display "${YELLOW}警告：未找到 'jq'，将使用简单的 URL 编码，可能不完全可靠。${NC}" "" "/dev/stderr"
        # 备用简单编码 (对于复杂字符不太可靠)
        encoded_message=$(printf %s "$message_content" | sed 's/[^a-zA-Z0-9._~-]/%&/g; s/ /%20/g')
    fi

    log_and_display "正在发送 Telegram 消息..." "" "/dev/stderr"
    if curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
        -d "chat_id=${TELEGRAM_CHAT_ID}" \
        -d "text=${encoded_message}" \
        -d "parse_mode=Markdown" > /dev/null; then
        log_and_display "${GREEN}Telegram 消息发送成功。${NC}" "" "/dev/stderr"
    else
        log_and_display "${RED}Telegram 消息发送失败！请检查 Bot Token 和 Chat ID，或网络连接。${NC}" "" "/dev/stderr"
    fi
}


# 1. 设置自动备份间隔
set_auto_backup_interval() {
    display_header
    echo -e "${BLUE}=== 1. 自动备份设定 ===${NC}"
    echo "当前自动备份间隔: ${AUTO_BACKUP_INTERVAL_DAYS} 天"
    echo ""
    read -rp "请输入新的自动备份间隔时间（天数，最小1天，例如 7 为 1 周）: " interval_input

    if [[ "$interval_input" =~ ^[0-9]+$ ]] && [ "$interval_input" -ge 1 ]; then
        AUTO_BACKUP_INTERVAL_DAYS="$interval_input"
        save_config
        log_and_display "${GREEN}自动备份间隔已成功设置为：${AUTO_BACKUP_INTERVAL_DAYS} 天。${NC}"
        log_and_display "${YELLOW}提示：现在您只需确保 Cron Job 每天运行此脚本一次。脚本会根据您设置的间隔自动判断是否执行备份。${NC}"
        log_and_display "${YELLOW}Cron Job 条目示例 (请将 /path/to/your_script.sh 替换为实际路径):${NC}"
        log_and_display "${YELLOW}0 0 * * * bash /path/to/your_script.sh check_auto_backup > /dev/null 2>&1${NC}" # 每天午夜运行
    else
        log_and_display "${RED}输入无效，请输入一个大于等于 1 的整数。${NC}"
    fi
    press_enter_to_continue
}

# 2. 手动备份
manual_backup() {
    display_header
    echo -e "${BLUE}=== 2. 手动备份 ===${NC}"
    # 检查是否有至少一个备份路径
    if [ ${#BACKUP_SOURCE_PATHS_ARRAY[@]} -eq 0 ]; then
        log_and_display "${RED}错误：没有设置任何备份源路径。请先通过 '3. 自定义备份路径' 添加路径。${NC}"
        press_enter_to_continue
        return 1
    fi
    log_and_display "您选择了手动备份，立即执行备份上传。" "${GREEN}"
    perform_backup "手动备份"
    press_enter_to_continue
}

# --- 修改后的 3. 自定义备份路径 ---
add_backup_path() {
    display_header
    echo -e "${BLUE}=== 添加备份路径 ===${NC}"
    read -rp "请输入要备份的文件或文件夹的绝对路径（例如 /home/user/mydata 或 /etc/nginx/nginx.conf）: " path_input

    local resolved_path=$(realpath -q "$path_input" 2>/dev/null)

    if [[ -z "$resolved_path" ]]; then
        log_and_display "${RED}错误：输入的路径无效或不存在。${NC}"
    elif [[ ! -d "$resolved_path" && ! -f "$resolved_path" ]]; then
        log_and_display "${RED}错误：输入的路径 '$resolved_path' 不存在或不是有效的文件/目录。${NC}"
    else
        # 检查是否已存在
        local found=false
        for p in "${BACKUP_SOURCE_PATHS_ARRAY[@]}"; do
            if [[ "$p" == "$resolved_path" ]]; then
                found=true
                break
            fi
        done

        if "$found"; then
            log_and_display "${YELLOW}该路径 '$resolved_path' 已存在于备份列表中。${NC}"
        else
            BACKUP_SOURCE_PATHS_ARRAY+=("$resolved_path")
            save_config
            log_and_display "${GREEN}备份路径 '$resolved_path' 已成功添加。${NC}"
        fi
    fi
    press_enter_to_continue
}

view_and_manage_backup_paths() {
    while true; do
        display_header
        echo -e "${BLUE}=== 查看/管理备份路径 ===${NC}"
        if [ ${#BACKUP_SOURCE_PATHS_ARRAY[@]} -eq 0 ]; then
            log_and_display "${YELLOW}当前没有设置任何备份路径。${NC}"
            press_enter_to_continue
            break
        fi

        echo "当前备份路径列表:"
        for i in "${!BACKUP_SOURCE_PATHS_ARRAY[@]}"; do
            echo "  $((i+1)). ${BACKUP_SOURCE_PATHS_ARRAY[$i]}"
        done
        echo ""
        echo "1. 修改现有路径"
        echo "2. 删除路径"
        echo "0. 返回自定义备份路径菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"
        read -rp "请输入选项: " sub_choice

        case $sub_choice in
            1) # 修改路径
                read -rp "请输入要修改的路径序号: " path_index
                if [[ "$path_index" =~ ^[0-9]+$ ]] && [ "$path_index" -ge 1 ] && [ "$path_index" -le ${#BACKUP_SOURCE_PATHS_ARRAY[@]} ]; then
                    local current_path="${BACKUP_SOURCE_PATHS_ARRAY[$((path_index-1))]}"
                    read -rp "您正在修改路径 '${current_path}'。请输入新的绝对路径: " new_path_input

                    local resolved_new_path=$(realpath -q "$new_path_input" 2>/dev/null)

                    if [[ -z "$resolved_new_path" ]]; then
                        log_and_display "${RED}错误：输入的路径无效或不存在。${NC}"
                    elif [[ ! -d "$resolved_new_path" && ! -f "$resolved_new_path" ]]; then
                        log_and_display "${RED}错误：输入的路径 '$resolved_new_path' 不存在或不是有效的文件/目录。${NC}"
                    else
                        # 移除目录的尾部斜杠，但保留文件路径的完整性
                        if [[ -d "$resolved_new_path" ]]; then
                            resolved_new_path="${resolved_new_path%/}"
                        fi
                        BACKUP_SOURCE_PATHS_ARRAY[$((path_index-1))]="$resolved_new_path"
                        save_config
                        log_and_display "${GREEN}路径已成功修改为：${resolved_new_path}${NC}"
                    fi
                else
                    log_and_display "${RED}无效的路径序号。${NC}"
                fi
                press_enter_to_continue
                ;;
            2) # 删除路径
                read -rp "请输入要删除的路径序号: " path_index
                if [[ "$path_index" =~ ^[0-9]+$ ]] && [ "$path_index" -ge 1 ] && [ "$path_index" -le ${#BACKUP_SOURCE_PATHS_ARRAY[@]} ]; then
                    log_and_display "${YELLOW}警告：您确定要删除路径 '${BACKUP_SOURCE_PATHS_ARRAY[$((path_index-1))]}'吗？(y/N)${NC}"
                    read -rp "请确认: " confirm_delete
                    if [[ "$confirm_delete" =~ ^[Yy]$ ]]; then
                        # 从数组中删除元素
                        unset 'BACKUP_SOURCE_PATHS_ARRAY[$((path_index-1))]'
                        BACKUP_SOURCE_PATHS_ARRAY=("${BACKUP_SOURCE_PATHS_ARRAY[@]}") # 重新索引数组
                        save_config
                        log_and_display "${GREEN}路径已成功删除。${NC}"
                    else
                        log_and_display "取消删除路径。" "${BLUE}"
                    fi
                else
                    log_and_display "${RED}无效的路径序号。${NC}"
                fi
                press_enter_to_continue
                ;;
            0)
                log_and_display "返回自定义备份路径菜单。" "${BLUE}"
                break
                ;;
            *)
                log_and_display "${RED}无效的选项，请重新输入。${NC}"
                press_enter_to_continue
                ;;
        esac
    done
}

# 3. 自定义备份路径主函数
set_backup_path() {
    while true; do
        display_header
        echo -e "${BLUE}=== 3. 自定义备份路径 ===${NC}"
        echo "当前已配置备份路径数量: ${#BACKUP_SOURCE_PATHS_ARRAY[@]} 个"
        echo ""
        echo "1. 添加新的备份路径"
        echo "2. 查看/修改/删除现有备份路径"
        echo "0. 返回主菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"
        read -rp "请输入选项: " choice

        case $choice in
            1) add_backup_path ;;
            2) view_and_manage_backup_paths ;;
            0)
                log_and_display "返回主菜单。" "${BLUE}"
                break
                ;;
            *)
                log_and_display "${RED}无效的选项，请重新输入。${NC}"
                press_enter_to_continue
                ;;
        esac
    done
}

# 4. 压缩格式信息 (保持不变)
display_compression_info() {
    display_header
    echo -e "${BLUE}=== 4. 压缩包格式 ===${NC}"
    log_and_display "本脚本当前支持的压缩格式为：${GREEN}ZIP${NC}。" ""
    log_and_display "如果您需要其他格式（如 .tar.gz），请修改脚本中 'perform_backup' 函数的压缩命令。" "${YELLOW}"
    press_enter_to_continue
}

# --- 云存储连接测试和内容列表 ---

# 测试 S3/R2 连接
test_s3_r2_connection() {
    if [[ -z "$S3_ACCESS_KEY" || -z "$S3_SECRET_KEY" || -z "$S3_ENDPOINT" || -z "$S3_BUCKET_NAME" ]]; then
        log_and_display "${RED}S3/R2 配置不完整，无法测试连接。请先填写 Access Key, Secret Key, Endpoint 和 Bucket 名称。${NC}" "" "/dev/stderr"
        return 1
    fi

    log_and_display "正在测试 S3/R2 连接到桶：${S3_BUCKET_NAME}..." "${BLUE}" "/dev/stderr"

    export AWS_ACCESS_KEY_ID="$S3_ACCESS_KEY"
    export AWS_SECRET_ACCESS_KEY="$S3_SECRET_KEY"

    local test_output=""
    local test_status=1

    if command -v aws &> /dev/null; then
        # 尝试使用 s3api list-objects-v2，因为 aws s3 ls 有时在某些环境下对选项解析有问题
        if { test_output=$(aws s3api list-objects-v2 --bucket "$S3_BUCKET_NAME" --max-keys 1 --endpoint-url "$S3_ENDPOINT" 2>&1); } then
            test_status=0
        else
            test_status=$?
        fi
    elif command -v s3cmd &> /dev/null; then
        log_and_display "${YELLOW}正在使用 s3cmd 进行连接测试。请确保 ~/.s3cfg 已正确配置 Cloudflare R2。${NC}" "" "/dev/stderr"
        if { test_output=$(s3cmd ls "s3://${S3_BUCKET_NAME}/" 2>&1); } then
            test_status=0
        else
            test_status=$?
        fi
    else
        log_and_display "${RED}未找到 'awscli' 或 's3cmd' 命令，无法测试 S3/R2 连接。${NC}" "" "/dev/stderr"
        unset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY
        return 1
    fi

    unset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY

    if [ "$test_status" -eq 0 ]; then
        log_and_display "${GREEN}S3/R2 连接成功！${NC}" "" "/dev/stderr"
        return 0
    else
        log_and_display "${RED}S3/R2 连接失败！请检查配置、凭证和网络连接。错误信息: ${test_output}${NC}" "" "/dev/stderr"
        return 1
    fi
}

# Helper function to list direct sub-folders AND files for S3/R2 under a given prefix
# Parameter 1: The parent prefix to list from (e.g., "", "myfolder/")
# Returns: List of content names (e.g., "myfolder (文件夹)", "myfile.txt (文件)") to stdout on success, empty list and non-zero exit on failure.
get_s3_r2_direct_contents() {
    local parent_prefix="$1"
    # Ensure parent_prefix doesn't start with / for S3 API calls, but does end with / for consistent prefix matching
    parent_prefix="${parent_prefix#/}" # Remove leading slash
    if [[ -n "$parent_prefix" && "${parent_prefix: -1}" != "/" ]]; then
        parent_prefix="${parent_prefix}/"
    fi
    # If parent_prefix is empty, it means root, and we don't want an extra slash in API calls
    if [[ -z "$parent_prefix" ]]; then
        parent_prefix=""
    fi

    export AWS_ACCESS_KEY_ID="$S3_ACCESS_KEY"
    export AWS_SECRET_ACCESS_KEY="$S3_SECRET_KEY"
    local contents=() # To store both folders and files, with type indicator
    local result_status=1 # Assume failure

    log_and_display "正在尝试获取 S3/R2 中 '${parent_prefix:-根目录}' 的直接子文件夹和文件..." "${BLUE}" "/dev/stderr"

    local cmd_output=""
    local cmd_status=1

    if command -v aws &> /dev/null; then
        if command -v jq &> /dev/null; then
            # Use aws s3api list-objects-v2 to get CommonPrefixes (folders) and Contents (files)
            if { cmd_output=$(aws s3api list-objects-v2 \
                --bucket "$S3_BUCKET_NAME" \
                --prefix "$parent_prefix" \
                --delimiter '/' \
                --endpoint-url "$S3_ENDPOINT" \
                --query '{CommonPrefixes: CommonPrefixes[].Prefix, Contents: Contents[].Key}' \
                --output json 2>&1); } then
                cmd_status=0
            else
                cmd_status=$?
                log_and_display "${RED}S3/R2 列表失败 (awscli + jq)！请检查桶名、路径、端点、权限或 jq 安装。错误: ${cmd_output}${NC}" "" "/dev/stderr"
                unset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY
                return 1
            fi

            if [ "$cmd_status" -eq 0 ]; then
                local folders_json=$(echo "$cmd_output" | jq -r '.CommonPrefixes[] | select(. != null)' 2>/dev/null)
                local files_json=$(echo "$cmd_output" | jq -r '.Contents[] | select(. != null)' 2>/dev/null)

                # Add folders, stripping parent_prefix and adding type suffix
                if [[ -n "$folders_json" ]]; then
                    # We expect 'CommonPrefixes' to already end with '/', so remove parent_prefix and then remove trailing slash for clean name.
                    mapfile -t -O "${#contents[@]}" contents <<< "$(echo "$folders_json" | sed "s|^${parent_prefix}||" | sed 's|/$||' | grep -E '\S' | awk '{print $1" (文件夹)"}')"
                fi
                
                # Add files, stripping parent_prefix and filtering out directory entries themselves
                if [[ -n "$files_json" ]]; then
                    mapfile -t -O "${#contents[@]}" contents <<< "$(echo "$files_json" | sed "s|^${parent_prefix}||" | grep -E '\S' | awk '{print $1" (文件)"}' | grep -v '^$' | grep -v '^\.\.?$')"
                fi

                # Sort the combined list alphabetically
                IFS=$'\n' contents=($(sort <<<"${contents[*]}"))
                unset IFS
                
                result_status=0 # Success
            fi
        else # Fallback without jq (less robust)
            log_and_display "${YELLOW}未找到 'jq' 命令，尝试使用不那么健壮的 'aws s3 ls'。${NC}" "" "/dev/stderr"
            if { cmd_output=$(aws s3 ls "s3://${S3_BUCKET_NAME}/${parent_prefix}" --endpoint-url "$S3_ENDPOINT" 2>&1); } then
                cmd_status=0
            else
                cmd_status=$?
                log_and_display "${RED}S3/R2 列表失败 (awscli without jq)！请检查桶名、路径、端点或权限。错误: ${cmd_output}${NC}" "" "/dev/stderr"
                unset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY
                return 1
            fi

            if [ "$cmd_status" -eq 0 ]; then
                # Parse lines: 'PRE folder_name/' for directories, size date time file_name for files
                while IFS= read -r line; do
                    if [[ "$line" =~ ^PRE\ (.*)/$ ]]; then
                        local folder_name="${BASH_REMATCH[1]}"
                        contents+=("${folder_name} (文件夹)")
                    elif [[ "$line" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}\ [0-9]{2}:[0-9]{2}:[0-9]{2}\ +[0-9]+\ +(.+)$ ]]; then
                        local file_name="${BASH_REMATCH[1]}"
                        contents+=("${file_name} (文件)")
                    fi
                done <<< "$(echo "$cmd_output" | sed "s|^${parent_prefix}||" | grep -v '^\.$' | grep -v '^\.\.$')"
                
                # Sort the combined list
                IFS=$'\n' contents=($(sort <<<"${contents[*]}"))
                unset IFS
                
                result_status=0 # Success
            fi
        fi
    elif command -v s3cmd &> /dev/null; then
        log_and_display "${YELLOW}正在使用 s3cmd 尝试列出 S3/R2 子文件夹和文件。此方法可能不如awscli全面。${NC}" "" "/dev/stderr"
        if { cmd_output=$(s3cmd ls "s3://${S3_BUCKET_NAME}/${parent_prefix}" 2>&1); } then
            cmd_status=0
        else
            cmd_status=$?
            log_and_display "${RED}S3/R2 列表失败 (s3cmd)！请检查桶名、路径、端点或权限。错误: ${cmd_output}${NC}" "" "/dev/stderr"
            unset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY
            return 1
        fi
        if [ "$cmd_status" -eq 0 ]; then
            while IFS= read -r line; do
                local item_path_full=$(echo "$line" | awk '{print $NF}')
                local item_path_relative=$(echo "$item_path_full" | sed 's|s3://'"${S3_BUCKET_NAME//./\\.}"'/'"${parent_prefix//./\\.}"'|\?||' | sed 's|/$||' | grep -v '^$' | grep -v '^\.\.?$')
                if [[ -n "$item_path_relative" ]]; then
                    if [[ "$line" =~ \ /$ ]]; then # Directories end with '/' in s3cmd ls output (before sed)
                        contents+=("${item_path_relative} (文件夹)")
                    else
                        contents+=("${item_path_relative} (文件)")
                    fi
                fi
            done <<< "$cmd_output"
            
            # Sort the combined list
            IFS=$'\n' contents=($(sort <<<"${contents[*]}"))
            unset IFS

            result_status=0 # Success
        fi
    else
        log_and_display "${RED}未找到 'awscli' 或 's3cmd' 命令，无法列出 S3/R2 文件夹和文件。${NC}" "" "/dev/stderr"
    fi
    unset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY

    # Output found contents
    printf '%s\n' "${contents[@]}"
    return "$result_status" # Return 0 for success, 1 for failure
}


# Test WebDAV connection
test_webdav_connection() {
    if [[ -z "$WEBDAV_URL" || -z "$WEBDAV_USERNAME" || -z "$WEBDAV_PASSWORD" ]]; then
        log_and_display "${RED}WebDAV 配置不完整，无法测试连接。请先填写 URL, 用户名和密码。${NC}" "" "/dev/stderr"
        return 1
    fi

    log_and_display "正在测试 WebDAV 连接到：${WEBDAV_URL}..." "${BLUE}" "/dev/stderr"

    # 使用 PROPFIND 方法测试连接，并检查 HTTP 状态码
    local http_code=$(curl -s -o /dev/null -w "%{http_code}" -L -k --user "$WEBDAV_USERNAME:$WEBDAV_PASSWORD" --request PROPFIND --header "Depth: 1" "${WEBDAV_URL%/}/" 2>/dev/null)
    local curl_status=$? # 获取 curl 的退出状态码

    if [ "$curl_status" -eq 0 ] && [[ "$http_code" -ge 200 && "$http_code" -lt 300 ]]; then
        log_and_display "${GREEN}WebDAV 连接成功！ (HTTP状态码: ${http_code})${NC}" "" "/dev/stderr"
        return 0
    else
        log_and_display "${RED}WebDAV 连接失败！HTTP状态码: ${http_code}。请检查配置、凭证和网络连接。${NC}" "" "/dev/stderr"
        log_and_display "${RED}Curl 错误码: ${curl_status}。${NC}" "" "/dev/stderr"
        return 1
    fi
}

# Helper function to list direct sub-folders AND files for WebDAV under a given URL
# Parameter 1: The current full URL of the parent directory to list (e.g., "http://your.webdav.server/path/to/parent/")
# Returns: List of content names (e.g., "myfolder (文件夹)", "myfile.txt (文件)") to stdout on success, empty list and non-zero exit on failure.
get_webdav_direct_contents() {
    local current_full_url="${1%/}/" # Ensure trailing slash for PROPFIND
    
    if ! test_webdav_connection; then # Re-test connection for safety
        log_and_display "${RED}WebDAV 连接失败，无法获取子文件夹或文件列表。${NC}" "" "/dev/stderr"
        return 1
    fi
    
    log_and_display "正在获取 WebDAV 服务器中 '${current_full_url}' 的子文件夹和文件列表..." "${BLUE}" "/dev/stderr"
    local contents=() # To store both folders and files
    local curl_output=""
    local result_status=1

    # Using Depth: 1 to list direct children
    if { curl_output=$(curl -s -L -k --user "$WEBDAV_USERNAME:$WEBDAV_PASSWORD" --request PROPFIND --header "Depth: 1" "$current_full_url" 2>&1); } then
        result_status=0
    else
        result_status=$?
        log_and_display "${RED}WebDAV 列表失败！错误: ${curl_output}${NC}" "" "/dev/stderr"
    fi

    if [ "$result_status" -eq 0 ] && [[ -n "$curl_output" ]]; then
        # Escape the current_full_url for sed pattern matching
        local current_full_url_escaped=$(echo "$current_full_url" | sed 's|/|\\/|g; s|\.|\\.|g; s|&|\\&|g')

        # Extract hrefs. Filter out the parent directory itself and then classify.
        # hrefs ending with '/' are directories. Others are files.
        while IFS= read -r href; do
            # Remove the base URL and current path prefix
            local item_name=$(echo "$href" | sed "s|^${current_full_url_escaped}||")
            # Remove any trailing slash from item_name for proper display
            local display_name="${item_name%/}"
            
            # Skip empty entries, and special "." ".." directories which are implicitly handled by navigation logic
            if [[ -z "$display_name" || "$display_name" == "." || "$display_name" == ".." ]]; then
                continue
            fi

            if [[ "$href" =~ /$ ]]; then # It's a directory
                contents+=("${display_name} (文件夹)")
            else # It's a file
                contents+=("${display_name} (文件)")
            fi
        done <<< "$(echo "$curl_output" | grep -oP '<D:href>\K([^<]+)(?=</D:href>)')"
    else
        log_and_display "${YELLOW}WebDAV 路径 '${current_full_url}' 下没有检测到子文件夹或文件。${NC}" "" "/dev/stderr"
    fi
    
    # Sort the combined list
    IFS=$'\n' contents=($(sort <<<"${contents[*]}"))
    unset IFS
    printf '%s\n' "${contents[@]}"
    return 0
}


# --- [修改] FTP/FTPS/SFTP functions ---

# Test FTP connection
test_ftp_connection() {
    if [[ -z "$FTP_HOST" || -z "$FTP_USERNAME" || -z "$FTP_PASSWORD" ]]; then
        log_and_display "${RED}FTP 配置不完整，无法测试连接。请先填写主机、用户名和密码。${NC}" "" "/dev/stderr"
        return 1
    fi

    log_and_display "正在测试 FTP 连接到：${FTP_HOST}:${FTP_PORT}..." "${BLUE}" "/dev/stderr"

    local lftp_output=""
    local lftp_status=1

    # 使用 here-document 传递命令，更清晰
    # 增加超时时间，使用 cls 代替 ls
    if { lftp_output=$(lftp -p "$FTP_PORT" -u "$FTP_USERNAME,$FTP_PASSWORD" "$FTP_HOST" <<EOF
set cmd:long-timeout 15
set cmd:timeout 15
set ftp:use-passive-mode true
cls -F /
quit
EOF
    2>&1); }; then
        lftp_status=0
    else
        lftp_status=$?
    fi

    if [ "$lftp_status" -eq 0 ]; then
        log_and_display "${GREEN}FTP 连接成功！${NC}" "" "/dev/stderr"
        return 0
    else
        log_and_display "${RED}FTP 连接失败！请检查配置、凭证、端口和网络连接。错误信息: ${lftp_output}${NC}" "" "/dev/stderr"
        return 1
    fi
}

# Helper function to list direct sub-folders AND files for FTP
get_ftp_direct_contents() {
    local host="$1" user="$2" pass="$3" port="$4" parent_path="$5"
    if [[ "$parent_path" != "/" && "${parent_path: -1}" != "/" ]]; then
        parent_path="${parent_path}/"
    fi

    log_and_display "正在获取 FTP 服务器中 '${parent_path}' 的子文件夹和文件列表..." "${BLUE}" "/dev/stderr"
    local contents=()
    local lftp_output=""
    local result_status=1

    # 使用统一的优化参数
    if { lftp_output=$(lftp -p "$port" -u "$user,$pass" "$host" <<EOF
set cmd:long-timeout 15
set cmd:timeout 15
set ftp:use-passive-mode true
cls -F "$parent_path"
quit
EOF
    2>&1); }; then
        result_status=0
    else
        result_status=$?
        log_and_display "${RED}FTP 连接失败或路径 '${parent_path}' 无效，无法获取子文件夹或文件列表。错误: ${lftp_output}${NC}" "" "/dev/stderr"
        return 1
    fi

    # 后续的解析逻辑
    if [ "$result_status" -eq 0 ] && [[ -n "$lftp_output" ]]; then
        while IFS= read -r line; do
            # lftp 的 cls -F 输出中，目录以 / 结尾
            local cleaned_name=$(echo "$line" | sed 's|/$||')
            if [[ "$cleaned_name" == "." || "$cleaned_name" == ".." || -z "$cleaned_name" ]]; then
                continue
            fi
            if [[ "$line" =~ /$ ]]; then
                contents+=("${cleaned_name} (文件夹)")
            else
                contents+=("${cleaned_name} (文件)")
            fi
        done <<< "$lftp_output"
    else
        log_and_display "${YELLOW}FTP 路径 '${parent_path}' 下没有检测到子文件夹或文件。${NC}" "" "/dev/stderr"
    fi

    IFS=$'\n' contents=($(sort <<<"${contents[*]}"))
    unset IFS
    printf '%s\n' "${contents[@]}"
    return 0
}

# Test FTPS connection
test_ftps_connection() {
    if [[ -z "$FTPS_HOST" || -z "$FTPS_USERNAME" || -z "$FTPS_PASSWORD" ]]; then
        log_and_display "${RED}FTPS 配置不完整，无法测试连接。请先填写主机、用户名和密码。${NC}" "" "/dev/stderr"
        return 1
    fi

    log_and_display "正在测试 FTPS 连接到：${FTPS_HOST}:${FTPS_PORT}..." "${BLUE}" "/dev/stderr"

    local lftp_output=""
    local lftp_status=1

    # 增加了 SSL/TLS 相关设置以提高兼容性
    if { lftp_output=$(lftp -p "$FTPS_PORT" -u "$FTPS_USERNAME,$FTPS_PASSWORD" "ftps://$FTPS_HOST" <<EOF
set cmd:long-timeout 15
set cmd:timeout 15
set ftp:use-passive-mode true
# 强制使用 SSL/TLS，并加密数据通道，增强可靠性
set ftp:ssl-force true
set ftp:ssl-protect-data true
# [重要] 如果服务器使用自签名证书，此项必须设置为 no，否则会因证书验证失败而卡住
set ssl:verify-certificate no
cls -F /
quit
EOF
    2>&1); }; then
        lftp_status=0
    else
        lftp_status=$?
    fi

    if [ "$lftp_status" -eq 0 ]; then
        log_and_display "${GREEN}FTPS 连接成功！${NC}" "" "/dev/stderr"
        return 0
    else
        log_and_display "${RED}FTPS 连接失败！请检查配置、凭证、端口和网络连接。错误信息: ${lftp_output}${NC}" "" "/dev/stderr"
        return 1
    fi
}


# Helper function to list direct sub-folders AND files for FTPS
get_ftps_direct_contents() {
    local host="$1" user="$2" pass="$3" port="$4" parent_path="$5"
    if [[ "$parent_path" != "/" && "${parent_path: -1}" != "/" ]]; then
        parent_path="${parent_path}/"
    fi

    log_and_display "正在获取 FTPS 服务器中 '${parent_path}' 的子文件夹和文件列表..." "${BLUE}" "/dev/stderr"
    local contents=()
    local lftp_output=""
    local result_status=1

    # 使用统一的优化参数
    if { lftp_output=$(lftp -p "$port" -u "$user,$pass" "ftps://$host" <<EOF
set cmd:long-timeout 15
set cmd:timeout 15
set ftp:use-passive-mode true
set ftp:ssl-force true
set ftp:ssl-protect-data true
set ssl:verify-certificate no
cls -F "$parent_path"
quit
EOF
    2>&1); }; then
        result_status=0
    else
        result_status=$?
        log_and_display "${RED}FTPS 连接失败或路径 '${parent_path}' 无效，无法获取子文件夹或文件列表。错误: ${lftp_output}${NC}" "" "/dev/stderr"
        return 1
    fi

    # 后续的解析逻辑
    if [ "$result_status" -eq 0 ] && [[ -n "$lftp_output" ]]; then
        while IFS= read -r line; do
            local cleaned_name=$(echo "$line" | sed 's|/$||')
            if [[ "$cleaned_name" == "." || "$cleaned_name" == ".." || -z "$cleaned_name" ]]; then
                continue
            fi
            if [[ "$line" =~ /$ ]]; then
                contents+=("${cleaned_name} (文件夹)")
            else
                contents+=("${cleaned_name} (文件)")
            fi
        done <<< "$lftp_output"
    else
        log_and_display "${YELLOW}FTPS 路径 '${parent_path}' 下没有检测到子文件夹或文件。${NC}" "" "/dev/stderr"
    fi

    IFS=$'\n' contents=($(sort <<<"${contents[*]}"))
    unset IFS
    printf '%s\n' "${contents[@]}"
    return 0
}

# [修改] Test SFTP connection using lftp
test_sftp_connection() {
    if [[ -z "$SFTP_HOST" || -z "$SFTP_USERNAME" || -z "$SFTP_PASSWORD" ]]; then
        log_and_display "${RED}SFTP 配置不完整，无法测试连接。请先填写主机、用户名和密码。${NC}" "" "/dev/stderr"
        return 1
    fi

    log_and_display "正在使用 lftp 测试 SFTP 连接到：${SFTP_USERNAME}@${SFTP_HOST}:${SFTP_PORT}..." "${BLUE}" "/dev/stderr"
    log_and_display "${YELLOW}注意：lftp 会自动处理密码或密钥认证。如果遇到主机密钥问题，请手动连接一次 sftp ${SFTP_USERNAME}@${SFTP_HOST} -p ${SFTP_PORT} 以接受密钥。${NC}" "" "/dev/stderr"

    local lftp_output=""
    local lftp_status=1

    if { lftp_output=$(lftp -p "$SFTP_PORT" -u "$SFTP_USERNAME,$SFTP_PASSWORD" "sftp://$SFTP_HOST" <<EOF
set cmd:long-timeout 15
set cmd:timeout 15
set sftp:auto-confirm yes
cls -F /
quit
EOF
    2>&1); }; then
        lftp_status=0
    else
        lftp_status=$?
    fi
    
    if [ "$lftp_status" -eq 0 ]; then
        log_and_display "${GREEN}SFTP 连接成功！${NC}" "" "/dev/stderr"
        return 0
    else
        log_and_display "${RED}SFTP 连接失败！请检查配置、凭证、端口和网络连接。错误信息: ${lftp_output}${NC}" "" "/dev/stderr"
        return 1
    fi
}

# [修改] Helper function to list direct sub-folders AND files for SFTP using lftp
get_sftp_direct_contents() {
    local host="$1" user="$2" pass="$3" port="$4" parent_path="$5"
    if [[ "$parent_path" != "/" && "${parent_path: -1}" != "/" ]]; then
        parent_path="${parent_path}/"
    fi

    log_and_display "正在获取 SFTP 服务器中 '${parent_path}' 的子文件夹和文件列表..." "${BLUE}" "/dev/stderr"
    local contents=()
    local lftp_output=""
    local result_status=1

    if { lftp_output=$(lftp -p "$port" -u "$user,$pass" "sftp://$host" <<EOF
set cmd:long-timeout 15
set cmd:timeout 15
set sftp:auto-confirm yes
cls -F "$parent_path"
quit
EOF
    2>&1); }; then
        result_status=0
    else
        result_status=$?
        log_and_display "${RED}SFTP 连接失败或路径 '${parent_path}' 无效，无法获取子文件夹或文件列表。错误: ${lftp_output}${NC}" "" "/dev/stderr"
        return 1
    fi

    # Parsing logic is now identical to FTP/FTPS
    if [ "$result_status" -eq 0 ] && [[ -n "$lftp_output" ]]; then
        while IFS= read -r line; do
            local cleaned_name=$(echo "$line" | sed 's|/$||')
            if [[ "$cleaned_name" == "." || "$cleaned_name" == ".." || -z "$cleaned_name" ]]; then
                continue
            fi
            if [[ "$line" =~ /$ ]]; then
                contents+=("${cleaned_name} (文件夹)")
            else
                contents+=("${cleaned_name} (文件)")
            fi
        done <<< "$lftp_output"
    else
        log_and_display "${YELLOW}SFTP 路径 '${parent_path}' 下没有检测到子文件夹或文件。${NC}" "" "/dev/stderr"
    fi
    
    IFS=$'\n' contents=($(sort <<<"${contents[*]}"))
    unset IFS
    printf '%s\n' "${contents[@]}"
    return 0
}


# ================================================================
# ===      增强型路径选择函数 (交互式浏览)           ===
# ================================================================

choose_s3_r2_path() {
    local initial_path="${S3_BACKUP_PATH:-/}" # Start from currently configured path or root
    local current_remote_path="$initial_path"
    local final_selected_path="" # The path user finally confirms

    # Normalize initial path: ensure it starts with / and ends with / if not root
    if [[ "${current_remote_path:0:1}" != "/" ]]; then
        current_remote_path="/$current_remote_path"
    fi
    if [[ "$current_remote_path" != "/" && "${current_remote_path: -1}" != "/" ]]; then
        current_remote_path="${current_remote_path}/"
    fi

    while true; do
        display_header
        echo -e "${BLUE}=== 设置 S3/R2 备份目标路径 ===${NC}"
        echo -e "当前浏览路径: ${YELLOW}${current_remote_path:-/}${NC}\n"

        # S3 prefixes don't usually start with /
        local s3_display_path="${current_remote_path#/}"
        local remote_contents_str=$(get_s3_r2_direct_contents "$s3_display_path") # 调用新的函数
        local get_contents_status=$?
        local remote_contents_array=()

        if [ "$get_contents_status" -ne 0 ]; then
            log_and_display "${RED}获取 S3/R2 文件夹和文件列表失败，请检查配置或重试。${NC}"
            press_enter_to_continue
            continue # Continue the while loop to re-display options
        elif [[ -n "$remote_contents_str" ]]; then
            mapfile -t remote_contents_array <<< "$remote_contents_str"
        fi

        if [ ${#remote_contents_array[@]} -gt 0 ]; then
            echo "当前目录内容 (文件夹和文件):"
            for i in "${!remote_contents_array[@]}"; do
                echo "  $((i+1)). ${remote_contents_array[$i]}"
            done
            echo ""
        else
            echo "当前路径下没有检测到子文件夹或文件。"
        fi

        echo -e "${BLUE}------------------------------------------------${NC}"
        echo "操作选项:"
        if [[ "$current_remote_path" != "/" ]]; then
            echo -e "  ${GREEN}..${NC} - 返回上一级目录"
        fi
        echo -e "  ${GREEN}k${NC} - 将当前路径 '${current_remote_path:-/}' 设置为备份目标"
        echo -e "  ${GREEN}a${NC} - 手动输入一个新的路径 (绝对路径或相对于当前路径)"
        echo -e "  ${GREEN}c${NC} - 取消并返回上一级菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"

        read -rp "请输入您的选择 (数字或字母): " choice

        case "$choice" in
            ".." )
                if [[ "$current_remote_path" != "/" ]]; then
                    current_remote_path="${current_remote_path%/}"
                    current_remote_path="$(dirname "$current_remote_path")"
                    if [[ "$current_remote_path" == "." ]]; then
                        current_remote_path="/"
                    else
                        current_remote_path="${current_remote_path}/"
                    fi
                    log_and_display "已返回上一级目录: ${current_remote_path:-/}" "${BLUE}"
                else
                    log_and_display "${YELLOW}已在根目录，无法返回上一级。${NC}"
                fi
                press_enter_to_continue
                ;;
            [0-9]* ) # If it's a number, try to navigate into it if it's a folder
                if [ "$choice" -ge 1 ] && [ "$choice" -le ${#remote_contents_array[@]} ]; then
                    local chosen_item_with_type="${remote_contents_array[$((choice-1))]}"
                    # Check if the chosen item is a directory by looking for the " (文件夹)" suffix
                    if echo "$chosen_item_with_type" | grep -q " (文件夹)$"; then
                        local chosen_folder="$(echo "$chosen_item_with_type" | sed 's/\ (文件夹)$//')"
                        current_remote_path="${current_remote_path}${chosen_folder}/" # Append the clean folder name and ensure slash
                        log_and_display "已进入目录: ${current_remote_path}" "${GREEN}"
                    else
                        log_and_display "${YELLOW}您选择的是一个文件，不能进入。请选择一个文件夹或按 'k' 键确认当前目录。${NC}"
                    fi
                else
                    log_and_display "${RED}无效的数字序号，请重新输入。${NC}"
                fi
                press_enter_to_continue
                ;;
            [kK] )
                final_selected_path="$current_remote_path"
                break # Exit the while loop to confirm
                ;;
            [aA] )
                read -rp "请输入新的 S3/R2 目标路径（绝对路径或相对于 '${current_remote_path:-/}'）：" new_path_input
                if [[ "$new_path_input" =~ ^/ ]]; then # Absolute path
                    final_selected_path="$new_path_input"
                else # Relative path
                    local base_for_relative="${current_remote_path%/}"
                    final_selected_path="${base_for_relative}/${new_path_input}"
                fi
                # Ensure selected path ends with a slash if it's not root and not explicitly a file name
                if [[ -n "$final_selected_path" && "$final_selected_path" != "/" && "${final_selected_path: -1}" != "/" ]]; then
                    final_selected_path="${final_selected_path}/"
                fi
                break # Exit the while loop to confirm
                ;;
            [cC] )
                log_and_display "取消设置 S3/R2 备份路径。" "${BLUE}"
                return 1 # Indicate cancellation
                ;;
            * )
                log_and_display "${RED}无效的输入，请重新输入。${NC}"
                press_enter_to_continue
                ;;
        esac
    done

    # Final confirmation after loop exit
    local display_path_confirm="${final_selected_path:-/ (根目录)}"
    read -rp "最终确认您选择的 S3/R2 目标路径是 '${display_path_confirm}'。确认吗？(y/N): " confirm_path
    if [[ "$confirm_path" =~ ^[Yy]$ ]]; then
        # S3_BACKUP_PATH should not start with a leading slash for awscli compatibility
        S3_BACKUP_PATH="${final_selected_path#/}"
        log_and_display "${GREEN}S3/R2 备份路径已设置为：${display_path_confirm}${NC}"
        return 0 # Success
    else
        log_and_display "${YELLOW}取消设置，请重新选择。${NC}"
        return 1 # User wants to re-do or cancel
    fi
}


choose_webdav_path() {
    local initial_path="${WEBDAV_BACKUP_PATH:-/}"
    local current_remote_path="$initial_path"
    local final_selected_path=""

    # Normalize initial path
    if [[ "${current_remote_path:0:1}" != "/" ]]; then
        current_remote_path="/$current_remote_path"
    fi
    if [[ "$current_remote_path" != "/" && "${current_remote_path: -1}" != "/" ]]; then
        current_remote_path="${current_remote_path}/"
    fi

    while true; do
        display_header
        echo -e "${BLUE}=== 设置 WebDAV 备份目标路径 ===${NC}"
        echo -e "当前浏览路径: ${YELLOW}${current_remote_path:-/}${NC}\n"

        # Construct the full URL for the current path
        local base_webdav_url="${WEBDAV_URL%/}" # Ensure no trailing slash on base URL
        local current_full_webdav_url="${base_webdav_url}${current_remote_path}"

        local remote_contents_str=$(get_webdav_direct_contents "$current_full_webdav_url")
        local get_contents_status=$?
        local remote_contents_array=()

        if [ "$get_contents_status" -ne 0 ]; then
            log_and_display "${RED}获取 WebDAV 文件夹和文件列表失败，请检查配置或重试。${NC}"
            press_enter_to_continue
            continue
        elif [[ -n "$remote_contents_str" ]]; then
            mapfile -t remote_contents_array <<< "$remote_contents_str"
        fi


        if [ ${#remote_contents_array[@]} -gt 0 ]; then
            echo "当前目录内容 (文件夹和文件):"
            for i in "${!remote_contents_array[@]}"; do
                echo "  $((i+1)). ${remote_contents_array[$i]}"
            done
            echo ""
        else
            echo "当前路径下没有检测到子文件夹或文件。"
        fi

        echo -e "${BLUE}------------------------------------------------${NC}"
        echo "操作选项:"
        if [[ "$current_remote_path" != "/" ]]; then
            echo -e "  ${GREEN}..${NC} - 返回上一级目录"
        fi
        echo -e "  ${GREEN}k${NC} - 将当前路径 '${current_remote_path:-/}' 设置为备份目标"
        echo -e "  ${GREEN}a${NC} - 手动输入一个新的路径 (绝对路径或相对于当前路径)"
        echo -e "  ${GREEN}c${NC} - 取消并返回上一级菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"

        read -rp "请输入您的选择 (数字或字母): " choice

        case "$choice" in
            ".." )
                if [[ "$current_remote_path" != "/" ]]; then
                    current_remote_path="${current_remote_path%/}"
                    current_remote_path="$(dirname "$current_remote_path")"
                    if [[ "$current_remote_path" == "." ]]; then
                        current_remote_path="/"
                    else
                        current_remote_path="${current_remote_path}/"
                    fi
                    log_and_display "已返回上一级目录: ${current_remote_path:-/}" "${BLUE}"
                else
                    log_and_display "${YELLOW}已在根目录，无法返回上一级。${NC}"
                fi
                press_enter_to_continue
                ;;
            [0-9]* )
                if [ "$choice" -ge 1 ] && [ "$choice" -le ${#remote_contents_array[@]} ]; then
                    local chosen_item_with_type="${remote_contents_array[$((choice-1))]}"
                    if echo "$chosen_item_with_type" | grep -q " (文件夹)$"; then
                        local chosen_folder="$(echo "$chosen_item_with_type" | sed 's/\ (文件夹)$//')"
                        current_remote_path="${current_remote_path}${chosen_folder}/"
                        log_and_display "已进入目录: ${current_remote_path}" "${GREEN}"
                    else
                        log_and_display "${YELLOW}您选择的是一个文件，不能进入。请选择一个文件夹或按 'k' 键确认当前目录。${NC}"
                    fi
                else
                    log_and_display "${RED}无效的数字序号，请重新输入。${NC}"
                fi
                press_enter_to_continue
                ;;
            [kK] )
                final_selected_path="$current_remote_path"
                break
                ;;
            [aA] )
                read -rp "请输入新的 WebDAV 目标路径（绝对路径或相对于 '${current_remote_path:-/}'）：" new_path_input
                if [[ "$new_path_input" =~ ^/ ]]; then
                    final_selected_path="$new_path_input"
                else
                    local base_for_relative="${current_remote_path%/}"
                    final_selected_path="${base_for_relative}/${new_path_input}"
                fi
                if [[ -n "$final_selected_path" && "$final_selected_path" != "/" && "${final_selected_path: -1}" != "/" ]]; then
                    final_selected_path="${final_selected_path}/"
                fi
                break
                ;;
            [cC] )
                log_and_display "取消设置 WebDAV 备份路径。" "${BLUE}"
                return 1
                ;;
            * )
                log_and_display "${RED}无效的输入，请重新输入。${NC}"
                press_enter_to_continue
                ;;
        esac
    done

    local display_path_confirm="${final_selected_path:-/ (根目录)}"
    read -rp "最终确认您选择的 WebDAV 目标路径是 '${display_path_confirm}'。确认吗？(y/N): " confirm_path
    if [[ "$confirm_path" =~ ^[Yy]$ ]]; then
        WEBDAV_BACKUP_PATH="$final_selected_path"
        log_and_display "${GREEN}WebDAV 备份路径已设置为：${display_path_confirm}${NC}"
        return 0
    else
        log_and_display "${YELLOW}取消设置，请重新选择。${NC}"
        return 1
    fi
}

choose_ftp_path() {
    local initial_path="${FTP_BACKUP_PATH:-/}"
    local current_remote_path="$initial_path"
    local final_selected_path=""

    # Normalize initial path
    if [[ "${current_remote_path:0:1}" != "/" ]]; then
        current_remote_path="/$current_remote_path"
    fi
    if [[ "$current_remote_path" != "/" && "${current_remote_path: -1}" != "/" ]]; then
        current_remote_path="${current_remote_path}/"
    fi

    while true; do
        display_header
        echo -e "${BLUE}=== 设置 FTP 备份目标路径 ===${NC}"
        echo -e "当前浏览路径: ${YELLOW}${current_remote_path:-/}${NC}\n"

        local remote_contents_str=$(get_ftp_direct_contents "$FTP_HOST" "$FTP_USERNAME" "$FTP_PASSWORD" "$FTP_PORT" "$current_remote_path")
        local get_contents_status=$?
        local remote_contents_array=()

        if [ "$get_contents_status" -ne 0 ]; then
            log_and_display "${RED}获取 FTP 文件夹和文件列表失败，请检查配置或重试。${NC}"
            press_enter_to_continue
            continue
        elif [[ -n "$remote_contents_str" ]]; then
            mapfile -t remote_contents_array <<< "$remote_contents_str"
        fi

        if [ ${#remote_contents_array[@]} -gt 0 ]; then
            echo "当前目录内容 (文件夹和文件):"
            for i in "${!remote_contents_array[@]}"; do
                echo "  $((i+1)). ${remote_contents_array[$i]}"
            done
            echo ""
        else
            echo "当前路径下没有检测到子文件夹或文件。"
        fi

        echo -e "${BLUE}------------------------------------------------${NC}"
        echo "操作选项:"
        if [[ "$current_remote_path" != "/" ]]; then
            echo -e "  ${GREEN}..${NC} - 返回上一级目录"
        fi
        echo -e "  ${GREEN}k${NC} - 将当前路径 '${current_remote_path:-/}' 设置为备份目标"
        echo -e "  ${GREEN}a${NC} - 手动输入一个新的路径 (绝对路径或相对于当前路径)"
        echo -e "  ${GREEN}c${NC} - 取消并返回上一级菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"

        read -rp "请输入您的选择 (数字或字母): " choice

        case "$choice" in
            ".." )
                if [[ "$current_remote_path" != "/" ]]; then
                    current_remote_path="${current_remote_path%/}"
                    current_remote_path="$(dirname "$current_remote_path")"
                    if [[ "$current_remote_path" == "." ]]; then
                        current_remote_path="/"
                    else
                        current_remote_path="${current_remote_path}/"
                    fi
                    log_and_display "已返回上一级目录: ${current_remote_path:-/}" "${BLUE}"
                else
                    log_and_display "${YELLOW}已在根目录，无法返回上一级。${NC}"
                fi
                press_enter_to_continue
                ;;
            [0-9]* )
                if [ "$choice" -ge 1 ] && [ "$choice" -le ${#remote_contents_array[@]} ]; then
                    local chosen_item_with_type="${remote_contents_array[$((choice-1))]}"
                    if echo "$chosen_item_with_type" | grep -q " (文件夹)$"; then
                        local chosen_folder="$(echo "$chosen_item_with_type" | sed 's/\ (文件夹)$//')"
                        current_remote_path="${current_remote_path}${chosen_folder}/"
                        log_and_display "已进入目录: ${current_remote_path}" "${GREEN}"
                    else
                        log_and_display "${YELLOW}您选择的是一个文件，不能进入。请选择一个文件夹或按 'k' 键确认当前目录。${NC}"
                    fi
                else
                    log_and_display "${RED}无效的数字序号，请重新输入。${NC}"
                fi
                press_enter_to_continue
                ;;
            [kK] )
                final_selected_path="$current_remote_path"
                break
                ;;
            [aA] )
                read -rp "请输入新的 FTP 目标路径（绝对路径或相对于 '${current_remote_path:-/}'）：" new_path_input
                if [[ "$new_path_input" =~ ^/ ]]; then
                    final_selected_path="$new_path_input"
                else
                    local base_for_relative="${current_remote_path%/}"
                    final_selected_path="${base_for_relative}/${new_path_input}"
                fi
                if [[ -n "$final_selected_path" && "$final_selected_path" != "/" && "${final_selected_path: -1}" != "/" ]]; then
                    final_selected_path="${final_selected_path}/"
                fi
                break
                ;;
            [cC] )
                log_and_display "取消设置 FTP 备份路径。" "${BLUE}"
                return 1
                ;;
            * )
                log_and_display "${RED}无效的输入，请重新输入。${NC}"
                press_enter_to_continue
                ;;
        esac
    done

    local display_path_confirm="${final_selected_path:-/ (根目录)}"
    read -rp "最终确认您选择的 FTP 目标路径是 '${display_path_confirm}'。确认吗？(y/N): " confirm_path
    if [[ "$confirm_path" =~ ^[Yy]$ ]]; then
        FTP_BACKUP_PATH="$final_selected_path"
        log_and_display "${GREEN}FTP 备份路径已设置为：${display_path_confirm}${NC}"
        return 0
    else
        log_and_display "${YELLOW}取消设置，请重新选择。${NC}"
        return 1
    fi
}

choose_ftps_path() {
    local initial_path="${FTPS_BACKUP_PATH:-/}"
    local current_remote_path="$initial_path"
    local final_selected_path=""

    # Normalize initial path
    if [[ "${current_remote_path:0:1}" != "/" ]]; then
        current_remote_path="/$current_remote_path"
    fi
    if [[ "$current_remote_path" != "/" && "${current_remote_path: -1}" != "/" ]]; then
        current_remote_path="${current_remote_path}/"
    fi

    while true; do
        display_header
        echo -e "${BLUE}=== 设置 FTPS 备份目标路径 ===${NC}"
        echo -e "当前浏览路径: ${YELLOW}${current_remote_path:-/}${NC}\n"

        local remote_contents_str=$(get_ftps_direct_contents "$FTPS_HOST" "$FTPS_USERNAME" "$FTPS_PASSWORD" "$FTPS_PORT" "$current_remote_path")
        local get_contents_status=$?
        local remote_contents_array=()

        if [ "$get_contents_status" -ne 0 ]; then
            log_and_display "${RED}获取 FTPS 文件夹和文件列表失败，请检查配置或重试。${NC}"
            press_enter_to_continue
            continue
        elif [[ -n "$remote_contents_str" ]]; then
            mapfile -t remote_contents_array <<< "$remote_contents_str"
        fi


        if [ ${#remote_contents_array[@]} -gt 0 ]; then
            echo "当前目录内容 (文件夹和文件):"
            for i in "${!remote_contents_array[@]}"; do
                echo "  $((i+1)). ${remote_contents_array[$i]}"
            done
            echo ""
        else
            echo "当前路径下没有检测到子文件夹或文件。"
        fi

        echo -e "${BLUE}------------------------------------------------${NC}"
        echo "操作选项:"
        if [[ "$current_remote_path" != "/" ]]; then
            echo -e "  ${GREEN}..${NC} - 返回上一级目录"
        fi
        echo -e "  ${GREEN}k${NC} - 将当前路径 '${current_remote_path:-/}' 设置为备份目标"
        echo -e "  ${GREEN}a${NC} - 手动输入一个新的路径 (绝对路径或相对于当前路径)"
        echo -e "  ${GREEN}c${NC} - 取消并返回上一级菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"

        read -rp "请输入您的选择 (数字或字母): " choice

        case "$choice" in
            ".." )
                if [[ "$current_remote_path" != "/" ]]; then
                    current_remote_path="${current_remote_path%/}"
                    current_remote_path="$(dirname "$current_remote_path")"
                    if [[ "$current_remote_path" == "." ]]; then
                        current_remote_path="/"
                    else
                        current_remote_path="${current_remote_path}/"
                    fi
                    log_and_display "已返回上一级目录: ${current_remote_path:-/}" "${BLUE}"
                else
                    log_and_display "${YELLOW}已在根目录，无法返回上一级。${NC}"
                fi
                press_enter_to_continue
                ;;
            [0-9]* )
                if [ "$choice" -ge 1 ] && [ "$choice" -le ${#remote_contents_array[@]} ]; then
                    local chosen_item_with_type="${remote_contents_array[$((choice-1))]}"
                    if echo "$chosen_item_with_type" | grep -q " (文件夹)$"; then
                        local chosen_folder="$(echo "$chosen_item_with_type" | sed 's/\ (文件夹)$//')"
                        current_remote_path="${current_remote_path}${chosen_folder}/"
                        log_and_display "已进入目录: ${current_remote_path}" "${GREEN}"
                    else
                        log_and_display "${YELLOW}您选择的是一个文件，不能进入。请选择一个文件夹或按 'k' 键确认当前目录。${NC}"
                    fi
                else
                    log_and_display "${RED}无效的数字序号，请重新输入。${NC}"
                fi
                press_enter_to_continue
                ;;
            [kK] )
                final_selected_path="$current_remote_path"
                break
                ;;
            [aA] )
                read -rp "请输入新的 FTPS 目标路径（绝对路径或相对于 '${current_remote_path:-/}'）：" new_path_input
                if [[ "$new_path_input" =~ ^/ ]]; then
                    final_selected_path="$new_path_input"
                else
                    local base_for_relative="${current_remote_path%/}"
                    final_selected_path="${base_for_relative}/${new_path_input}"
                fi
                if [[ -n "$final_selected_path" && "$final_selected_path" != "/" && "${final_selected_path: -1}" != "/" ]]; then
                    final_selected_path="${final_selected_path}/"
                fi
                break
                ;;
            [cC] )
                log_and_display "取消设置 FTPS 备份路径。" "${BLUE}"
                return 1
                ;;
            * )
                log_and_display "${RED}无效的输入，请重新输入。${NC}"
                press_enter_to_continue
                ;;
        esac
    done

    local display_path_confirm="${final_selected_path:-/ (根目录)}"
    read -rp "最终确认您选择的 FTPS 目标路径是 '${display_path_confirm}'。确认吗？(y/N): " confirm_path
    if [[ "$confirm_path" =~ ^[Yy]$ ]]; then
        FTPS_BACKUP_PATH="$final_selected_path"
        log_and_display "${GREEN}FTPS 备份路径已设置为：${display_path_confirm}${NC}"
        return 0
    else
        log_and_display "${YELLOW}取消设置，请重新选择。${NC}"
        return 1
    fi
}

choose_sftp_path() {
    local initial_path="${SFTP_BACKUP_PATH:-/}"
    local current_remote_path="$initial_path"
    local final_selected_path=""

    # Normalize initial path
    if [[ "${current_remote_path:0:1}" != "/" ]]; then
        current_remote_path="/$current_remote_path"
    fi
    if [[ "$current_remote_path" != "/" && "${current_remote_path: -1}" != "/" ]]; then
        current_remote_path="${current_remote_path}/"
    fi

    while true; do
        display_header
        echo -e "${BLUE}=== 设置 SFTP 备份目标路径 ===${NC}"
        echo -e "当前浏览路径: ${YELLOW}${current_remote_path:-/}${NC}\n"

        local remote_contents_str=$(get_sftp_direct_contents "$SFTP_HOST" "$SFTP_USERNAME" "$SFTP_PASSWORD" "$SFTP_PORT" "$current_remote_path")
        local get_contents_status=$?
        local remote_contents_array=()

        if [ "$get_contents_status" -ne 0 ]; then
            log_and_display "${RED}获取 SFTP 文件夹和文件列表失败，请检查配置或重试。${NC}"
            press_enter_to_continue
            continue
        elif [[ -n "$remote_contents_str" ]]; then
            mapfile -t remote_contents_array <<< "$remote_contents_str"
        fi


        if [ ${#remote_contents_array[@]} -gt 0 ]; then
            echo "当前目录内容 (文件夹和文件):"
            for i in "${!remote_contents_array[@]}"; do
                echo "  $((i+1)). ${remote_contents_array[$i]}"
            done
            echo ""
        else
            echo "当前路径下没有检测到子文件夹或文件。"
        fi

        echo -e "${BLUE}------------------------------------------------${NC}"
        echo "操作选项:"
        if [[ "$current_remote_path" != "/" ]]; then
            echo -e "  ${GREEN}..${NC} - 返回上一级目录"
        fi
        echo -e "  ${GREEN}k${NC} - 将当前路径 '${current_remote_path:-/}' 设置为备份目标"
        echo -e "  ${GREEN}a${NC} - 手动输入一个新的路径 (绝对路径或相对于当前路径)"
        echo -e "  ${GREEN}c${NC} - 取消并返回上一级菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"

        read -rp "请输入您的选择 (数字或字母): " choice

        case "$choice" in
            ".." )
                if [[ "$current_remote_path" != "/" ]]; then
                    current_remote_path="${current_remote_path%/}"
                    current_remote_path="$(dirname "$current_remote_path")"
                    if [[ "$current_remote_path" == "." ]]; then
                        current_remote_path="/"
                    else
                        current_remote_path="${current_remote_path}/"
                    fi
                    log_and_display "已返回上一级目录: ${current_remote_path:-/}" "${BLUE}"
                else
                    log_and_display "${YELLOW}已在根目录，无法返回上一级。${NC}"
                fi
                press_enter_to_continue
                ;;
            [0-9]* )
                if [ "$choice" -ge 1 ] && [ "$choice" -le ${#remote_contents_array[@]} ]; then
                    local chosen_item_with_type="${remote_contents_array[$((choice-1))]}"
                    if echo "$chosen_item_with_type" | grep -q " (文件夹)$"; then
                        local chosen_folder="$(echo "$chosen_item_with_type" | sed 's/\ (文件夹)$//')"
                        current_remote_path="${current_remote_path}${chosen_folder}/"
                        log_and_display "已进入目录: ${current_remote_path}" "${GREEN}"
                    else
                        log_and_display "${YELLOW}您选择的是一个文件，不能进入。请选择一个文件夹或按 'k' 键确认当前目录。${NC}"
                    fi
                else
                    log_and_display "${RED}无效的数字序号，请重新输入。${NC}"
                fi
                press_enter_to_continue
                ;;
            [kK] )
                final_selected_path="$current_remote_path"
                break
                ;;
            [aA] )
                read -rp "请输入新的 SFTP 目标路径（绝对路径或相对于 '${current_remote_path:-/}'）：" new_path_input
                if [[ "$new_path_input" =~ ^/ ]]; then
                    final_selected_path="$new_path_input"
                else
                    local base_for_relative="${current_remote_path%/}"
                    final_selected_path="${base_for_relative}/${new_path_input}"
                fi
                if [[ -n "$final_selected_path" && "$final_selected_path" != "/" && "${final_selected_path: -1}" != "/" ]]; then
                    final_selected_path="${final_selected_path}/"
                fi
                break
                ;;
            [cC] )
                log_and_display "取消设置 SFTP 备份路径。" "${BLUE}"
                return 1
                ;;
            * )
                log_and_display "${RED}无效的输入，请重新输入。${NC}"
                press_enter_to_continue
                ;;
        esac
    done

    local display_path_confirm="${final_selected_path:-/ (根目录)}"
    read -rp "最终确认您选择的 SFTP 目标路径是 '${display_path_confirm}'。确认吗？(y/N): " confirm_path
    if [[ "$confirm_path" =~ ^[Yy]$ ]]; then
        SFTP_BACKUP_PATH="$final_selected_path"
        log_and_display "${GREEN}SFTP 备份路径已设置为：${display_path_confirm}${NC}"
        return 0
    else
        log_and_display "${YELLOW}取消设置，请重新选择。${NC}"
        return 1
    fi
}


# ================================================================
# ===      云存储账号管理菜单 (保持不变)             ===
# ================================================================

# 管理 S3/R2 账号设置
manage_s3_r2_account() {
    while true; do
        display_header
        echo -e "${BLUE}=== 管理 S3/R2 存储账号 ===${NC}"
        local s3_status="${RED}未配置${NC}"
        local s3_path_status="${YELLOW}未设置目标路径${NC}"

        # 判断 S3/R2 账号是否已配置
        if [[ -n "$S3_ACCESS_KEY" && -n "$S3_SECRET_KEY" && -n "$S3_ENDPOINT" && -n "$S3_BUCKET_NAME" ]]; then
            s3_status="${GREEN}已配置${NC} (桶: ${S3_BUCKET_NAME})"
            if [[ -n "$S3_BACKUP_PATH" ]]; then
                s3_path_status="${GREEN}已设置目标路径: ${S3_BACKUP_PATH}${NC}"
            fi
        fi

        echo "当前 S3/R2 账号状态: $s3_status"
        echo "S3/R2 目标路径状态: $s3_path_status"
        echo ""
        echo "1. 添加/修改 S3/R2 账号凭证"
        echo "2. 测试 S3/R2 连接"
        echo "3. 设置备份目标路径"
        echo "4. 清除 S3/R2 账号配置"
        echo "0. 返回云存储设定主菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"
        read -rp "请输入选项: " sub_choice

        case $sub_choice in
            1)
                log_and_display "--- 添加/修改 S3/R2 账号凭证 ---"
                log_and_display "${YELLOW}凭证将保存到本地配置文件，请确保配置文件安全！${NC}"
                # Changed: Do not display current Access Key directly
                read -rp "请输入 S3/R2 Access Key ID [当前: $(if [[ -n "$S3_ACCESS_KEY" ]]; then echo "已设置"; else echo "未设置"; fi)]: " input_key
                S3_ACCESS_KEY="${input_key:-$S3_ACCESS_KEY}" # 如果输入为空，保留当前值

                # Changed: Use -s for secret key and hide current value
                read -s -rp "请输入 S3/R2 Secret Access Key (留空不修改当前密钥): " input_secret
                echo "" # Newline after hidden input
                if [[ -n "$input_secret" ]]; then # Only update if new secret is provided
                    S3_SECRET_KEY="$input_secret"
                fi

                read -rp "请输入 S3/R2 Endpoint URL (例如 Cloudflare R2 的 https://<ACCOUNT_ID>.r2.cloudflarestorage.com) [当前: ${S3_ENDPOINT}]: " input_endpoint
                S3_ENDPOINT="${input_endpoint:-$S3_ENDPOINT}"

                read -rp "请输入 S3/R2 Bucket 名称 [当前: ${S3_BUCKET_NAME}]: " input_bucket
                S3_BUCKET_NAME="${input_bucket:-$S3_BUCKET_NAME}"

                save_config
                log_and_display "${GREEN}S3/R2 账号凭证已更新并保存。${NC}"
                press_enter_to_continue
                ;;
            2)
                test_s3_r2_connection
                press_enter_to_continue
                ;;
            3)
                # 检查凭证是否已设置 (修复了这里的逻辑错误)
                if [[ -z "$S3_ACCESS_KEY" || -z "$S3_SECRET_KEY" || -z "$S3_ENDPOINT" || -z "$S3_BUCKET_NAME" ]]; then # 修复这里的条件：全部检查是否为空
                    log_and_display "${RED}S3/R2 配置不完整，无法设置目标路径。请先通过选项 '1' 添加凭证。${NC}"
                else
                    if choose_s3_r2_path; then
                        save_config # 仅在路径成功设置后保存
                    fi
                fi
                press_enter_to_continue
                ;;
            4)
                log_and_display "${YELLOW}警告：这将清除所有 S3/R2 账号配置。确定吗？(y/N)${NC}"
                read -rp "请确认: " confirm_clear
                if [[ "$confirm_clear" =~ ^[Yy]$ ]]; then
                    S3_ACCESS_KEY=""
                    S3_SECRET_KEY=""
                    S3_ENDPOINT=""
                    S3_BUCKET_NAME=""
                    S3_BACKUP_PATH=""
                    BACKUP_TARGET_S3="false" # 禁用 S3 备份
                    save_config
                    log_and_display "${GREEN}S3/R2 账号配置已清除。${NC}"
                else
                    log_and_display "取消清除 S3/R2 账号配置。" "${BLUE}"
                fi
                press_enter_to_continue
                ;;
            0)
                log_and_display "返回云存储设定主菜单。" "${BLUE}"
                break
                ;;
            *)
                log_and_display "${RED}无效的选项，请重新输入。${NC}"
                press_enter_to_continue
                ;;
        esac
    done
}

# 管理 WebDAV 账号设置
manage_webdav_account() {
    while true; do
        display_header
        echo -e "${BLUE}=== 管理 WebDAV 存储账号 ===${NC}"
        local webdav_status="${RED}未配置${NC}"
        local webdav_path_status="${YELLOW}未设置目标路径${NC}"

        # 判断 WebDAV 账号是否已配置
        if [[ -n "$WEBDAV_URL" && -n "$WEBDAV_USERNAME" && -n "$WEBDAV_PASSWORD" ]]; then
            # 隐藏密码显示
            local display_url="${WEBDAV_URL}"
            display_url="${display_url/:\/\/www./:\/\/\*\*\*./}"
            webdav_status="${GREEN}已配置${NC} (URL: ${display_url} 用户名: ${WEBDAV_USERNAME})"
            if [[ -n "$WEBDAV_BACKUP_PATH" ]]; then
                webdav_path_status="${GREEN}已设置目标路径: ${WEBDAV_BACKUP_PATH}${NC}"
            fi
        fi

        echo "当前 WebDAV 账号状态: $webdav_status"
        echo "WebDAV 目标路径状态: $webdav_path_status"
        echo ""
        echo "1. 添加/修改 WebDAV 账号凭证"
        echo "2. 测试 WebDAV 连接"
        echo "3. 设置备份目标路径"
        echo "4. 清除 WebDAV 账号配置"
        echo "0. 返回云存储设定主菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"
        read -rp "请输入选项: " sub_choice

        case $sub_choice in
            1)
                log_and_display "--- 添加/修改 WebDAV 账号凭证 ---"
                log_and_display "${YELLOW}凭证将保存到本地配置文件，请确保配置文件安全！${NC}"
                read -rp "请输入 WebDAV URL (例如 http://your.webdav.server/path/) [当前: ${WEBDAV_URL}]: " input_url
                WEBDAV_URL="${input_url:-$WEBDAV_URL}"

                read -rp "请输入 WebDAV 用户名 [当前: ${WEBDAV_USERNAME}]: " input_username
                WEBDAV_USERNAME="${input_username:-$WEBDAV_USERNAME}"

                read -s -rp "请输入 WebDAV 密码 (留空不修改当前密码): " input_password
                echo "" # 隐藏输入后换行
                if [[ -n "$input_password" ]]; then # 仅在提供了新密码时才更新
                    WEBDAV_PASSWORD="$input_password"
                fi

                save_config
                log_and_display "${GREEN}WebDAV 账号凭证已更新并保存。${NC}"
                press_enter_to_continue
                ;;
            2)
                test_webdav_connection
                press_enter_to_continue
                ;;
            3)
                if [[ -z "$WEBDAV_URL" || -z "$WEBDAV_USERNAME" || -z "$WEBDAV_PASSWORD" ]]; then
                    log_and_display "${RED}WebDAV 配置不完整，无法设置目标路径。请先通过选项 '1' 添加凭证。${NC}"
                else
                    if choose_webdav_path; then
                        save_config # 仅在路径成功设置后保存
                    fi
                fi
                press_enter_to_continue
                ;;
            4)
                log_and_display "${YELLOW}警告：这将清除所有 WebDAV 账号配置。确定吗？(y/N)${NC}"
                read -rp "请确认: " confirm_clear
                if [[ "$confirm_clear" =~ ^[Yy]$ ]]; then
                    WEBDAV_URL=""
                    WEBDAV_USERNAME=""
                    WEBDAV_PASSWORD=""
                    WEBDAV_BACKUP_PATH=""
                    BACKUP_TARGET_WEBDAV="false" # 禁用 WebDAV 备份
                    save_config
                    log_and_display "${GREEN}WebDAV 账号配置已清除。${NC}"
                else
                    log_and_display "取消清除 WebDAV 账号配置。" "${BLUE}"
                fi
                press_enter_to_continue
                ;;
            0)
                log_and_display "返回云存储设定主菜单。" "${BLUE}"
                break
                ;;
            *)
                log_and_display "${RED}无效的选项，请重新输入。${NC}"
                press_enter_to_continue
                ;;
        esac
    done
}

# 管理 FTP 账号设置
manage_ftp_account() {
    while true; do
        display_header
        echo -e "${BLUE}=== 管理 FTP 存储账号 ===${NC}"
        local ftp_status="${RED}未配置${NC}"
        local ftp_path_status="${YELLOW}未设置目标路径${NC}"

        if [[ -n "$FTP_HOST" && -n "$FTP_USERNAME" && -n "$FTP_PASSWORD" ]]; then
            ftp_status="${GREEN}已配置${NC} (主机: ${FTP_HOST}:${FTP_PORT} 用户名: ${FTP_USERNAME})"
            if [[ -n "$FTP_BACKUP_PATH" ]]; then
                ftp_path_status="${GREEN}已设置目标路径: ${FTP_BACKUP_PATH}${NC}"
            fi
        fi

        echo "当前 FTP 账号状态: $ftp_status"
        echo "FTP 目标路径状态: $ftp_path_status"
        echo ""
        echo "1. 添加/修改 FTP 账号凭证"
        echo "2. 测试 FTP 连接"
        echo "3. 设置备份目标路径"
        echo "4. 清除 FTP 账号配置"
        echo "0. 返回云存储设定主菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"
        read -rp "请输入选项: " sub_choice

        case $sub_choice in
            1)
                log_and_display "--- 添加/修改 FTP 账号凭证 ---"
                log_and_display "${YELLOW}凭证将保存到本地配置文件，请确保配置文件安全！${NC}"
                read -rp "请输入 FTP 主机名 (例如 ftp.example.com) [当前: ${FTP_HOST}]: " input_host
                FTP_HOST="${input_host:-$FTP_HOST}"

                read -rp "请输入 FTP 用户名 [当前: ${FTP_USERNAME}]: " input_username
                FTP_USERNAME="${input_username:-$FTP_USERNAME}"

                read -s -rp "请输入 FTP 密码 (留空不修改当前密码): " input_password
                echo ""
                if [[ -n "$input_password" ]]; then
                    FTP_PASSWORD="$input_password"
                fi

                read -rp "请输入 FTP 端口 (默认: 21) [当前: ${FTP_PORT}]: " input_port
                FTP_PORT="${input_port:-$FTP_PORT}"
                [[ "$FTP_PORT" =~ ^[0-9]+$ ]] || FTP_PORT=21 # 确保是数字，否则恢复默认

                save_config
                log_and_display "${GREEN}FTP 账号凭证已更新并保存。${NC}"
                press_enter_to_continue
                ;;
            2)
                test_ftp_connection
                press_enter_to_continue
                ;;
            3)
                if [[ -z "$FTP_HOST" || -z "$FTP_USERNAME" || -z "$FTP_PASSWORD" ]]; then
                    log_and_display "${RED}FTP 配置不完整，无法设置目标路径。请先通过选项 '1' 添加凭证。${NC}"
                else
                    if choose_ftp_path; then
                        save_config
                    fi
                fi
                press_enter_to_continue
                ;;
            4)
                log_and_display "${YELLOW}警告：这将清除所有 FTP 账号配置。确定吗？(y/N)${NC}"
                read -rp "请确认: " confirm_clear
                if [[ "$confirm_clear" =~ ^[Yy]$ ]]; then
                    FTP_HOST=""
                    FTP_USERNAME=""
                    FTP_PASSWORD=""
                    FTP_PORT=21
                    FTP_BACKUP_PATH=""
                    BACKUP_TARGET_FTP="false"
                    save_config
                    log_and_display "${GREEN}FTP 账号配置已清除。${NC}"
                else
                    log_and_display "取消清除 FTP 账号配置。" "${BLUE}"
                fi
                press_enter_to_continue
                ;;
            0)
                log_and_display "返回云存储设定主菜单。" "${BLUE}"
                break
                ;;
            *)
                log_and_display "${RED}无效的选项，请重新输入。${NC}"
                press_enter_to_continue
                ;;
        esac
    done
}

# 管理 FTPS 账号设置
manage_ftps_account() {
    while true; do
        display_header
        echo -e "${BLUE}=== 管理 FTPS 存储账号 ===${NC}"
        local ftps_status="${RED}未配置${NC}"
        local ftps_path_status="${YELLOW}未设置目标路径${NC}"

        if [[ -n "$FTPS_HOST" && -n "$FTPS_USERNAME" && -n "$FTPS_PASSWORD" ]]; then
            ftps_status="${GREEN}已配置${NC} (主机: ${FTPS_HOST}:${FTPS_PORT} 用户名: ${FTPS_USERNAME})"
            if [[ -n "$FTPS_BACKUP_PATH" ]]; then
                ftps_path_status="${GREEN}已设置目标路径: ${FTPS_BACKUP_PATH}${NC}"
            fi
        fi

        echo "当前 FTPS 账号状态: $ftps_status"
        echo "FTPS 目标路径状态: $ftps_path_status"
        echo ""
        echo "1. 添加/修改 FTPS 账号凭证"
        echo "2. 测试 FTPS 连接"
        echo "3. 设置备份目标路径"
        echo "4. 清除 FTPS 账号配置"
        echo "0. 返回云存储设定主菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"
        read -rp "请输入选项: " sub_choice

        case $sub_choice in
            1)
                log_and_display "--- 添加/修改 FTPS 账号凭证 ---"
                log_and_display "${YELLOW}凭证将保存到本地配置文件，请确保配置文件安全！${NC}"
                read -rp "请输入 FTPS 主机名 (例如 ftps.example.com) [当前: ${FTPS_HOST}]: " input_host
                FTPS_HOST="${input_host:-$FTPS_HOST}"

                read -rp "请输入 FTPS 用户名 [当前: ${FTPS_USERNAME}]: " input_username
                FTPS_USERNAME="${input_username:-$FTPS_USERNAME}"

                read -s -rp "请输入 FTPS 密码 (留空不修改当前密码): " input_password
                echo "" # 隐藏输入后换行
                if [[ -n "$input_password" ]]; then # 仅在提供了新密码时才更新
                    FTPS_PASSWORD="$input_password"
                fi

                read -rp "请输入 FTPS 端口 (默认: 21) [当前: ${FTPS_PORT}]: " input_port
                FTPS_PORT="${input_port:-$FTPS_PORT}"
                [[ "$FTPS_PORT" =~ ^[0-9]+$ ]] || FTPS_PORT=21

                save_config
                log_and_display "${GREEN}FTPS 账号凭证已更新并保存。${NC}"
                press_enter_to_continue
                ;;
            2)
                test_ftps_connection
                press_enter_to_continue
                ;;
            3)
                if [[ -z "$FTPS_HOST" || -z "$FTPS_USERNAME" || -z "$FTPS_PASSWORD" ]]; then
                    log_and_display "${RED}FTPS 配置不完整，无法设置目标路径。请先通过选项 '1' 添加凭证。${NC}"
                else
                    if choose_ftps_path; then
                        save_config # 仅在路径成功设置后保存
                    fi
                fi
                press_enter_to_continue
                ;;
            4)
                log_and_display "${YELLOW}警告：这将清除所有 FTPS 账号配置。确定吗？(y/N)${NC}"
                read -rp "请确认: " confirm_clear
                if [[ "$confirm_clear" =~ ^[Yy]$ ]]; then
                    FTPS_HOST=""
                    FTPS_USERNAME=""
                    FTPS_PASSWORD=""
                    FTPS_PORT=21
                    FTPS_BACKUP_PATH=""
                    BACKUP_TARGET_FTPS="false"
                    save_config
                    log_and_display "${GREEN}FTPS 账号配置已清除。${NC}"
                else
                    log_and_display "取消清除 FTPS 账号配置。" "${BLUE}"
                fi
                press_enter_to_continue
                ;;
            0)
                log_and_display "返回云存储设定主菜单。" "${BLUE}"
                break
                ;;
            *)
                log_and_display "${RED}无效的选项，请重新输入。${NC}"
                press_enter_to_continue
                ;;
        esac
    done
}

# 管理 SFTP 账号设置
manage_sftp_account() {
    while true; do
        display_header
        echo -e "${BLUE}=== 管理 SFTP 存储账号 ===${NC}"
        local sftp_status="${RED}未配置${NC}"
        local sftp_path_status="${YELLOW}未设置目标路径${NC}"

        if [[ -n "$SFTP_HOST" && -n "$SFTP_USERNAME" && -n "$SFTP_PASSWORD" ]]; then
            sftp_status="${GREEN}已配置${NC} (主机: ${SFTP_HOST}:${SFTP_PORT} 用户名: ${SFTP_USERNAME})"
            if [[ -n "$SFTP_BACKUP_PATH" ]]; then
                sftp_path_status="${GREEN}已设置目标路径: ${SFTP_BACKUP_PATH}${NC}"
            fi
        fi

        echo "当前 SFTP 账号状态: $sftp_status"
        echo "SFTP 目标路径状态: $sftp_path_status"
        echo ""
        echo "1. 添加/修改 SFTP 账号凭证"
        echo "2. 测试 SFTP 连接"
        echo "3. 设置备份目标路径"
        echo "4. 清除 SFTP 账号配置"
        echo "0. 返回云存储设定主菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"
        read -rp "请输入选项: " sub_choice

        case $sub_choice in
            1)
                log_and_display "--- 添加/修改 SFTP 账号凭证 ---"
                log_and_display "${YELLOW}凭证将保存到本地配置文件，请确保配置文件安全！${NC}"
                log_and_display "${YELLOW}建议使用 SSH 密钥进行 SFTP 认证以提高安全性。${NC}"
                read -rp "请输入 SFTP 主机名 (例如 sftp.example.com 或 192.168.1.1) [当前: ${SFTP_HOST}]: " input_host
                SFTP_HOST="${input_host:-$SFTP_HOST}"

                read -rp "请输入 SFTP 用户名 [当前: ${SFTP_USERNAME}]: " input_username
                SFTP_USERNAME="${input_username:-$SFTP_USERNAME}"

                read -s -rp "请输入 SFTP 密码或密钥密码 (留空不修改当前密码): " input_password
                echo ""
                if [[ -n "$input_password" ]]; then
                    SFTP_PASSWORD="$input_password"
                fi

                read -rp "请输入 SFTP 端口 (默认: 22) [当前: ${SFTP_PORT}]: " input_port
                SFTP_PORT="${input_port:-$SFTP_PORT}"
                [[ "$SFTP_PORT" =~ ^[0-9]+$ ]] || SFTP_PORT=22

                save_config
                log_and_display "${GREEN}SFTP 账号凭证已更新并保存。${NC}"
                press_enter_to_continue
                ;;
            2)
                test_sftp_connection
                press_enter_to_continue
                ;;
            3)
                if [[ -z "$SFTP_HOST" || -z "$SFTP_USERNAME" || -z "$SFTP_PASSWORD" ]]; then
                    log_and_display "${RED}SFTP 配置不完整，无法设置目标路径。请先通过选项 '1' 添加凭证。${NC}"
                else
                    if choose_sftp_path; then
                        save_config
                    fi
                fi
                press_enter_to_continue
                ;;
            4)
                log_and_display "${YELLOW}警告：这将清除所有 SFTP 账号配置。确定吗？(y/N)${NC}"
                read -rp "请确认: " confirm_clear
                if [[ "$confirm_clear" =~ ^[Yy]$ ]]; then
                    SFTP_HOST=""
                    SFTP_USERNAME=""
                    SFTP_PASSWORD=""
                    SFTP_PORT=22
                    SFTP_BACKUP_PATH=""
                    BACKUP_TARGET_SFTP="false"
                    save_config
                    log_and_display "${GREEN}SFTP 账号配置已清除。${NC}"
                else
                    log_and_display "取消清除 SFTP 账号配置。" "${BLUE}"
                fi
                press_enter_to_continue
                ;;
            0)
                log_and_display "返回云存储设定主菜单。" "${BLUE}"
                break
                ;;
            *)
                log_and_display "${RED}无效的选项，请重新输入。${NC}"
                press_enter_to_continue
                ;;
        esac
    done
}

# 选择要使用的云存储目标
select_backup_targets() {
    while true; do
        display_header
        echo -e "${BLUE}=== 选择云备份目标 ===${NC}"
        echo "请选择要用于备份的云存储 (可多选，至少选择一个有效目标)："
        echo "------------------------------------------------"

        local s3_configured="false"
        local webdav_configured="false"
        local ftp_configured="false"
        local ftps_configured="false"
        local sftp_configured="false"

        # 检查 S3/R2 配置状态
        if [[ -n "$S3_ACCESS_KEY" && -n "$S3_SECRET_KEY" && -n "$S3_ENDPOINT" && -n "$S3_BUCKET_NAME" && -n "$S3_BACKUP_PATH" ]]; then
            s3_configured="true"
            echo -n "1. S3/R2 存储 (当前: "
            if [[ "$BACKUP_TARGET_S3" == "true" ]]; then echo -e "${GREEN}启用${NC})"
            else echo -e "${YELLOW}禁用${NC})" ; fi
            echo "       (已配置账号并设置路径: ${S3_BACKUP_PATH})"
        else
            echo -e "1. S3/R2 存储 (${RED}未完全配置，无法启用${NC})"
        fi

        # 检查 WebDAV 配置状态
        if [[ -n "$WEBDAV_URL" && -n "$WEBDAV_USERNAME" && -n "$WEBDAV_PASSWORD" && -n "$WEBDAV_BACKUP_PATH" ]]; then
            webdav_configured="true"
            echo -n "2. WebDAV 存储 (当前: "
            if [[ "$BACKUP_TARGET_WEBDAV" == "true" ]]; then echo -e "${GREEN}启用${NC})"
            else echo -e "${YELLOW}禁用${NC})" ; fi
            echo "       (已配置账号并设置路径: ${WEBDAV_BACKUP_PATH})"
        else
            echo -e "2. WebDAV 存储 (${RED}未完全配置，无法启用${NC})"
        fi

        # --- 新增 FTP/FTPS/SFTP 目标选择 ---
        if [[ -n "$FTP_HOST" && -n "$FTP_USERNAME" && -n "$FTP_PASSWORD" && -n "$FTP_BACKUP_PATH" ]]; then
            ftp_configured="true"
            echo -n "3. FTP 存储 (当前: "
            if [[ "$BACKUP_TARGET_FTP" == "true" ]]; then echo -e "${GREEN}启用${NC})"
            else echo -e "${YELLOW}禁用${NC})" ; fi
            echo "       (已配置账号并设置路径: ${FTP_BACKUP_PATH})"
        else
            echo -e "3. FTP 存储 (${RED}未完全配置，无法启用${NC})"
        fi

        if [[ -n "$FTPS_HOST" && -n "$FTPS_USERNAME" && -n "$FTPS_PASSWORD" && -n "$FTPS_BACKUP_PATH" ]]; then
            ftps_configured="true"
            echo -n "4. FTPS 存储 (当前: "
            if [[ "$BACKUP_TARGET_FTPS" == "true" ]]; then echo -e "${GREEN}启用${NC})"
            else echo -e "${YELLOW}禁用${NC})" ; fi
            echo "       (已配置账号并设置路径: ${FTPS_BACKUP_PATH})"
        else
            echo -e "4. FTPS 存储 (${RED}未完全配置，无法启用${NC})"
        fi

        if [[ -n "$SFTP_HOST" && -n "$SFTP_USERNAME" && -n "$SFTP_PASSWORD" && -n "$SFTP_BACKUP_PATH" ]]; then
            sftp_configured="true"
            echo -n "5. SFTP 存储 (当前: "
            if [[ "$BACKUP_TARGET_SFTP" == "true" ]]; then echo -e "${GREEN}启用${NC})"
            else echo -e "${YELLOW}禁用${NC})" ; fi
            echo "       (已配置账号并设置路径: ${SFTP_BACKUP_PATH})"
        else
            echo -e "5. SFTP 存储 (${RED}未完全配置，无法启用${NC})"
        fi

        echo ""
        echo "0. 返回主菜单 (保存选择)"
        echo -e "${BLUE}------------------------------------------------${NC}"
        read -rp "请输入选项 (例如 '1', '2 3', '0'): " choice_input

        # Reset temporary targets based on current state before processing new input
        local temp_s3_target="$BACKUP_TARGET_S3"
        local temp_webdav_target="$BACKUP_TARGET_WEBDAV"
        local temp_ftp_target="$BACKUP_TARGET_FTP"
        local temp_ftps_target="$BACKUP_TARGET_FTPS"
        local temp_sftp_target="$BACKUP_TARGET_SFTP"

        # Initialize to false for fresh selection if user is providing specific numbers
        # If user inputs "1 3", only 1 and 3 should be true, others false.
        # If user inputs "0", keep current.
        if [[ "$choice_input" =~ [1-5] ]]; then # If any target number is chosen, reset all to false first
            temp_s3_target="false"
            temp_webdav_target="false"
            temp_ftp_target="false"
            temp_ftps_target="false"
            temp_sftp_target="false"
        fi

        local selections=($choice_input) # Split input into an array

        for sel in "${selections[@]}"; do
            case "$sel" in
                "1")
                    if [[ "$s3_configured" == "true" ]]; then
                        temp_s3_target="true"
                        log_and_display "已选择启用 S3/R2 备份。" "${GREEN}"
                    else
                        log_and_display "${RED}S3/R2 未完全配置，无法启用。${NC}"
                    fi
                    ;;
                "2")
                    if [[ "$webdav_configured" == "true" ]]; then
                        temp_webdav_target="true"
                        log_and_display "已选择启用 WebDAV 备份。" "${GREEN}"
                    else
                        log_and_display "${RED}WebDAV 未完全配置，无法启用。${NC}"
                    fi
                    ;;
                "3")
                    if [[ "$ftp_configured" == "true" ]]; then
                        temp_ftp_target="true"
                        log_and_display "已选择启用 FTP 备份。" "${GREEN}"
                    else
                        log_and_display "${RED}FTP 未完全配置，无法启用。${NC}"
                    fi
                    ;;
                "4")
                    if [[ "$ftps_configured" == "true" ]]; then
                        temp_ftps_target="true"
                        log_and_display "已选择启用 FTPS 备份。" "${GREEN}"
                    else
                        log_and_display "${RED}FTPS 未完全配置，无法启用。${NC}"
                    fi
                    ;;
                "5")
                    if [[ "$sftp_configured" == "true" ]]; then
                        temp_sftp_target="true"
                        log_and_display "已选择启用 SFTP 备份。" "${GREEN}"
                    else
                        log_and_display "${RED}SFTP 未完全配置，无法启用。${NC}"
                    fi
                    ;;
                "0") # Only if '0' is the only input
                    if [ "${#selections[@]}" -eq 1 ]; then
                        # If 0 is chosen alone, break out and save current state (which was possibly modified by other numbers if multi-select was intented)
                        # Or, if no specific targets were chosen, ensure all are false before breaking.
                        break
                    else
                        log_and_display "${RED}无效的选项组合。'0' 只能单独使用。${NC}"
                        temp_s3_target="$BACKUP_TARGET_S3" # Revert to previous state
                        temp_webdav_target="$BACKUP_TARGET_WEBDAV"
                        temp_ftp_target="$BACKUP_TARGET_FTP"
                        temp_ftps_target="$BACKUP_TARGET_FTPS"
                        temp_sftp_target="$BACKUP_TARGET_SFTP"
                    fi
                    ;;
                *)
                    log_and_display "${RED}无效的选项 '${sel}'，请重新输入。${NC}"
                    temp_s3_target="$BACKUP_TARGET_S3" # Revert to previous state
                    temp_webdav_target="$BACKUP_TARGET_WEBDAV"
                    temp_ftp_target="$BACKUP_TARGET_FTP"
                    temp_ftps_target="$BACKUP_TARGET_FTPS"
                    temp_sftp_target="$BACKUP_TARGET_SFTP"
                    ;;
            esac
        done

        if [ "$choice_input" == "0" ] || [[ "$choice_input" =~ [1-5] ]]; then # If user selected 0 or any numbers, proceed to save
            local any_target_enabled="false"
            if [[ "$temp_s3_target" == "true" || "$temp_webdav_target" == "true" || "$temp_ftp_target" == "true" || "$temp_ftps_target" == "true" || "$temp_sftp_target" == "true" ]]; then
                any_target_enabled="true"
            fi

            if [[ "$any_target_enabled" == "false" ]]; then
                log_and_display "${RED}警告：未选择任何有效备份目标。这会导致自动备份无法上传文件。${NC}"
                read -rp "确定要不选择任何目标吗？(y/N): " confirm_none
                if [[ ! "$confirm_none" =~ ^[Yy]$ ]]; then
                    continue # 重新显示菜单
                fi
            fi

            BACKUP_TARGET_S3="$temp_s3_target"
            BACKUP_TARGET_WEBDAV="$temp_webdav_target"
            BACKUP_TARGET_FTP="$temp_ftp_target"
            BACKUP_TARGET_FTPS="$temp_ftps_target"
            BACKUP_TARGET_SFTP="$temp_sftp_target"
            save_config
            log_and_display "备份目标设置已保存。" "${BLUE}"
            break # Exit the while loop
        fi
        press_enter_to_continue
    done
}


# 5. 云存储设定
set_cloud_storage() {
    while true; do
        display_header
        echo -e "${BLUE}=== 5. 云存储设定 ===${NC}"

        local s3_info="${RED}未配置${NC}"
        if [[ -n "$S3_ACCESS_KEY" && -n "$S3_BUCKET_NAME" ]]; then
            s3_info="${GREEN}已配置${NC} (桶: ${S3_BUCKET_NAME} | 路径: ${S3_BACKUP_PATH:-未设置})"
        fi

        local webdav_info="${RED}未配置${NC}"
        if [[ -n "$WEBDAV_URL" && -n "$WEBDAV_USERNAME" ]]; then
            local display_url="${WEBDAV_URL}"
            display_url="${display_url/:\/\/www./:\/\/\*\*\*./}"
            webdav_info="${GREEN}已配置${NC} (URL: ${display_url} | 用户名: ${WEBDAV_USERNAME} | 路径: ${WEBDAV_BACKUP_PATH:-未设置})"
        fi

        local ftp_info="${RED}未配置${NC}"
        if [[ -n "$FTP_HOST" && -n "$FTP_USERNAME" ]]; then
            ftp_info="${GREEN}已配置${NC} (主机: ${FTP_HOST}:${FTP_PORT} | 用户名: ${FTP_USERNAME} | 路径: ${FTP_BACKUP_PATH:-未设置})"
        fi

        local ftps_info="${RED}未配置${NC}"
        if [[ -n "$FTPS_HOST" && -n "$FTPS_USERNAME" ]]; then
            ftps_info="${GREEN}已配置${NC} (主机: ${FTPS_HOST}:${FTPS_PORT} | 用户名: ${FTPS_USERNAME} | 路径: ${FTPS_BACKUP_PATH:-未设置})"
        fi

        local sftp_info="${RED}未配置${NC}"
        if [[ -n "$SFTP_HOST" && -n "$SFTP_USERNAME" ]]; then
            sftp_info="${GREEN}已配置${NC} (主机: ${SFTP_HOST}:${SFTP_PORT} | 用户名: ${SFTP_USERNAME} | 路径: ${SFTP_BACKUP_PATH:-未设置})"
        fi

        echo "1. 选择云备份目标 (S3/R2: ${BACKUP_TARGET_S3}, WebDAV: ${BACKUP_TARGET_WEBDAV}, FTP: ${BACKUP_TARGET_FTP}, FTPS: ${BACKUP_TARGET_FTPS}, SFTP: ${BACKUP_TARGET_SFTP})"
        echo "   当前S3/R2账号: $s3_info"
        echo "   当前WebDAV账号: $webdav_info"
        echo "   当前FTP账号: $ftp_info"
        echo "   当前FTPS账号: $ftps_info"
        echo "   当前SFTP账号: $sftp_info"
        echo "2. 管理 S3/R2 账号设置"
        echo "3. 管理 WebDAV 账号设置"
        echo "4. 管理 FTP 账号设置"
        echo "5. 管理 FTPS 账号设置"
        echo "6. 管理 SFTP 账号设置"
        echo "0. 返回主菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"
        read -rp "请输入选项: " sub_choice

        case $sub_choice in
            1) select_backup_targets ;;
            2) manage_s3_r2_account ;;
            3) manage_webdav_account ;;
            4) manage_ftp_account ;;
            5) manage_ftps_account ;;
            6) manage_sftp_account ;;
            0)
                log_and_display "返回主菜单。" "${BLUE}"
                break
                ;;
            *)
                log_and_display "${RED}无效的选项，请重新输入。${NC}"
                press_enter_to_continue
                ;;
        esac
    done
}

# 6. 设置 Telegram 通知设定 (保持不变)
set_telegram_notification() {
    display_header
    echo -e "${BLUE}=== 6. 消息通知设定 (Telegram) ===${NC}"
    log_and_display "${YELLOW}Telegram Bot Token 和 Chat ID 将保存到本地配置文件，请确保配置文件安全！${NC}"
    read -rp "请输入 Telegram Bot Token (例如 123456:ABC-DEF1234ghIkl-79f): " TELEGRAM_BOT_TOKEN
    read -rp "请输入 Telegram Chat ID (例如 -123456789 或 123456789): " TELEGRAM_CHAT_ID
    save_config # 保存凭证到配置文件
    log_and_display "${GREEN}Telegram 通知配置已更新并保存。${NC}"
    log_and_display "${YELLOW}提示：您可以向 @BotFather 获取 Bot Token，然后向您的 Bot 发送消息，再访问 https://api.telegram.org/bot<YOUR_BOT_TOKEN>/getUpdates 获取 Chat ID。${NC}"
    press_enter_to_continue
}

# 7. 设置备份保留策略 (保持不变)
set_retention_policy() {
    while true; do
        display_header
        echo -e "${BLUE}=== 7. 设置备份保留策略 (云端) ===${NC}"
        echo "当前策略: "
        case "$RETENTION_POLICY_TYPE" in
            "none") echo -e "  ${YELLOW}无保留策略（所有备份将保留）${NC}" ;;
            "count") echo -e "  ${YELLOW}保留最新 ${RETENTION_VALUE} 个备份${NC}" ;;
            "days")  echo -e "  ${YELLOW}保留最近 ${RETENTION_VALUE} 天内的备份${NC}" ;;
            *)       echo -e "  ${YELLOW}未知策略或未设置${NC}" ;; # 添加默认情况
        esac
        echo ""
        echo "1. 设置按数量保留 (例如：保留最新的 5 个备份)"
        echo "2. 设置按天数保留 (例如：保留最近 30 天内的备份)"
        echo "3. 关闭保留策略"
        echo "0. 返回主菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"
        read -rp "请输入选项: " sub_choice

        case $sub_choice in
            1)
                read -rp "请输入要保留的备份数量 (例如 5): " value_input
                if [[ "$value_input" =~ ^[0-9]+$ ]] && [ "$value_input" -ge 1 ]; then
                    RETENTION_POLICY_TYPE="count"
                    RETENTION_VALUE="$value_input"
                    save_config
                    log_and_display "${GREEN}已设置保留最新 ${RETENTION_VALUE} 个备份的策略。${NC}"
                else
                    log_and_display "${RED}输入无效，请输入一个大于等于 1 的整数。${NC}"
                fi
                press_enter_to_continue
                ;;
            2)
                read -rp "请输入要保留备份的天数 (例如 30): " value_input
                if [[ "$value_input" =~ ^[0-9]+$ ]] && [ "$value_input" -ge 1 ]; then
                    RETENTION_POLICY_TYPE="days"
                    RETENTION_VALUE="$value_input"
                    save_config
                    log_and_display "${GREEN}已设置保留最近 ${RETENTION_VALUE} 天内的备份策略。${NC}"
                else
                    log_and_display "${RED}输入无效，请输入一个大于等于 1 的整数。${NC}"
                fi # Corrected from F
                press_enter_to_continue
                ;;
            3)
                RETENTION_POLICY_TYPE="none"
                RETENTION_VALUE=0
                save_config
                log_and_display "${GREEN}已关闭备份保留策略。${NC}"
                press_enter_to_continue
                ;;
            0)
                log_and_display "返回主菜单。" "${BLUE}"
                break
                ;;
            *)
                log_and_display "${RED}无效的选项，请重新输入。${NC}"
                press_enter_to_continue
                ;;
        esac
    done
}


# [修改] 应用保留策略的函数 (适应 lftp for SFTP)
apply_retention_policy() {
    log_and_display "${BLUE}--- 正在应用备份保留策略 ---${NC}"

    if [[ "$RETENTION_POLICY_TYPE" == "none" ]]; then
        log_and_display "未设置保留策略，跳过清理。" "${YELLOW}"
        return 0
    fi

    local current_timestamp=$(date +%s)
    local total_s3_backups_found=0
    local deleted_s3_count=0
    local total_webdav_backups_found=0
    local deleted_webdav_count=0
    local total_ftp_backups_found=0
    local deleted_ftp_count=0
    local total_ftps_backups_found=0
    local deleted_ftps_count=0
    local total_sftp_backups_found=0
    local deleted_sftp_count=0

    # Function to delete a file from a specific service
    delete_file() {
        local service_type="$1"
        local file_to_delete="$2"
        local delete_status=1
        case "$service_type" in
            "s3")
                export AWS_ACCESS_KEY_ID="$S3_ACCESS_KEY"
                export AWS_SECRET_ACCESS_KEY="$S3_SECRET_KEY"
                if command -v aws &> /dev/null; then
                    aws s3 rm "s3://${S3_BUCKET_NAME}/${S3_BACKUP_PATH}${file_to_delete}" --endpoint-url "$S3_ENDPOINT" &> /dev/null
                    delete_status=$?
                elif command -v s3cmd &> /dev/null; then
                    s3cmd del "s3://${S3_BUCKET_NAME}/${S3_BACKUP_PATH}${file_to_delete}" &> /dev/null
                    delete_status=$?
                fi
                unset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY
                ;;
            "webdav")
                curl -s -k --user "$WEBDAV_USERNAME:$WEBDAV_PASSWORD" -X DELETE "${WEBDAV_URL%/}/${WEBDAV_BACKUP_PATH}${file_to_delete}" > /dev/null
                delete_status=$?
                ;;
            "ftp")
                lftp -p "$FTP_PORT" -u "$FTP_USERNAME,$FTP_PASSWORD" "$FTP_HOST" <<EOF &>/dev/null
set cmd:long-timeout 15
set cmd:timeout 15
set ftp:use-passive-mode true
rm "$FTP_BACKUP_PATH$file_to_delete"
quit
EOF
                delete_status=$?
                ;;
            "ftps")
                lftp -p "$FTPS_PORT" -u "$FTPS_USERNAME,$FTPS_PASSWORD" "ftps://$FTPS_HOST" <<EOF &>/dev/null
set cmd:long-timeout 15
set cmd:timeout 15
set ftp:use-passive-mode true
set ftp:ssl-force true
set ftp:ssl-protect-data true
set ssl:verify-certificate no
rm "$FTPS_BACKUP_PATH$file_to_delete"
quit
EOF
                delete_status=$?
                ;;
            "sftp")
                # [修改] 使用 lftp 删除 SFTP 文件
                lftp -p "$SFTP_PORT" -u "$SFTP_USERNAME,$SFTP_PASSWORD" "sftp://$SFTP_HOST" <<EOF &>/dev/null
set cmd:long-timeout 15
set cmd:timeout 15
set sftp:auto-confirm yes
rm "$SFTP_BACKUP_PATH$file_to_delete"
quit
EOF
                delete_status=$?
                ;;
        esac
        return "$delete_status"
    }

    # Helper function for S3 retention to list all files under the S3_BACKUP_PATH
    get_s3_r2_all_files_for_retention() {
        local path_prefix="$1"
        export AWS_ACCESS_KEY_ID="$S3_ACCESS_KEY"
        export AWS_SECRET_ACCESS_KEY="$S3_SECRET_KEY"
        local files=()
        local cmd_output=""
        local cmd_status=1

        # Remove leading slash if present, as S3 paths don't usually start with / in ls
        path_prefix="${path_prefix#/}"

        if command -v aws &> /dev/null; then
            if { cmd_output=$(aws s3api list-objects-v2 --bucket "$S3_BUCKET_NAME" --prefix "$path_prefix" --query "Contents[].Key" --output text --endpoint-url "$S3_ENDPOINT" 2>&1); } then
                cmd_status=0
            else
                cmd_status=$?
                log_and_display "${RED}S3/R2 文件列表失败 (awscli)！错误: ${cmd_output}${NC}" "" "/dev/stderr"
            fi
            if [ "$cmd_status" -eq 0 ]; then
                mapfile -t files <<< "$(echo "$cmd_output" | sed "s|^${path_prefix}||" )"
            fi
        elif command -v s3cmd &> /dev/null; then
            if { cmd_output=$(s3cmd ls "s3://${S3_BUCKET_NAME}/${path_prefix}" 2>&1); } then
                cmd_status=0
            else
                cmd_status=$?
                log_and_display "${RED}S3/R2 文件列表失败 (s3cmd)！错误: ${cmd_output}${NC}" "" "/dev/stderr"
            fi
            if [ "$cmd_status" -eq 0 ]; then
                mapfile -t files <<< "$(echo "$cmd_output" | awk '{print $4}' | sed 's|s3://'"${S3_BUCKET_NAME//./\\.}"'/'"${path_prefix//./\\.}"'\?||' )"
            fi
        fi
        unset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY

        if [ ${#files[@]} -gt 0 ]; then
            printf '%s\n' "${files[@]}"
        fi
        return "$cmd_status" # Return the actual command status
    }


    # Generic function to process backups for a given service
    process_service_retention() {
        local service_type="$1" # e.g., "s3", "webdav", "ftp", "ftps", "sftp"
        local target_path_var_name="$2" # Name of the target path variable, e.g., "S3_BACKUP_PATH"
        local -n total_backups_found_ref="$3" # Reference to total_xxx_backups_found
        local -n deleted_count_ref="$4" # Reference to deleted_xxx_count

        local service_display_name=""
        local target_path=""
        local backups_array=()
        local get_list_status=1

        case "$service_type" in
            "s3") service_display_name="S3/R2";;
            "webdav") service_display_name="WebDAV";;
            "ftp") service_display_name="FTP";;
            "ftps") service_display_name="FTPS";;
            "sftp") service_display_name="SFTP";;
        esac

        eval "target_path=\$$target_path_var_name" # Get value of target path variable

        log_and_display "正在检查 ${service_display_name} 存储中的旧备份：${target_path}..."

        local raw_backups_list=""
        if [[ "$service_type" == "s3" ]]; then
            raw_backups_list=$(get_s3_r2_all_files_for_retention "$target_path")
            get_list_status=$?
        elif [[ "$service_type" == "webdav" ]]; then
            local base_webdav_url_for_retention="${WEBDAV_URL%/}"
            local curl_output=""
            if { curl_output=$(curl -s -L -k --user "$WEBDAV_USERNAME:$WEBDAV_PASSWORD" --request PROPFIND --header "Depth: infinity" "${base_webdav_url_for_retention}${target_path}" 2>&1); } then
                get_list_status=0
            else
                get_list_status=$?
                log_and_display "${RED}WebDAV 列出文件失败！错误: ${curl_output}${NC}" "" "/dev/stderr"
            fi
            # We specifically look for zip files that match the backup naming convention
            raw_backups_list=$(echo "$curl_output" | grep -oP '<D:href>\K([^<]*[a-zA-Z0-9_-]+_[0-9]{14}\.zip)(?=</D:href>)' | sed "s|^${base_webdav_url_for_retention//./\\.}${target_path//./\\.}\|/||" | sed "s|/${target_path//./\\.}\|/||")
        elif [[ "$service_type" == "ftp" ]]; then
            # Add timeout and passive mode settings
            if { raw_backups_list=$(lftp -u "$FTP_USERNAME","$FTP_PASSWORD" -p "$FTP_PORT" "$FTP_HOST" -e "set cmd:long-timeout 10; set cmd:timeout 10; set ftp:use-passive-mode yes; find ${target_path} -name '*_[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9].zip'; quit;" 2>&1); } then
                get_list_status=0
            else
                get_list_status=$?
                log_and_display "${RED}FTP 列出文件失败！错误: ${raw_backups_list}${NC}" "" "/dev/stderr"
            fi
            raw_backups_list=$(echo "$raw_backups_list" | sed "s|^${target_path}||")
        elif [[ "$service_type" == "ftps" ]]; then
            # Add timeout and passive mode settings
            if { raw_backups_list=$(lftp -u "$FTPS_USERNAME","$FTPS_PASSWORD" -p "$FTPS_PORT" ftps://"$FTPS_HOST" -e "set cmd:long-timeout 10; set cmd:timeout 10; set ftp:use-passive-mode yes; set ftp:ssl-force true; set ftp:ssl-protect-data true; set ssl:verify-certificate no; find ${target_path} -name '*_[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9].zip'; quit;" 2>&1); } then
                get_list_status=0
            else
                get_list_status=$?
                log_and_display "${RED}FTPS 列出文件失败！错误: ${raw_backups_list}${NC}" "" "/dev/stderr"
            fi
            raw_backups_list=$(echo "$raw_backups_list" | sed "s|^${target_path}||")
        elif [[ "$service_type" == "sftp" ]]; then
            # [修改] 使用 lftp find 列出 SFTP 文件
            if { raw_backups_list=$(lftp -u "$SFTP_USERNAME","$SFTP_PASSWORD" -p "$SFTP_PORT" sftp://"$SFTP_HOST" -e "set cmd:long-timeout 10; set cmd:timeout 10; set sftp:auto-confirm yes; find ${target_path} -name '*_[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9].zip'; quit;" 2>&1); } then
                get_list_status=0
            else
                get_list_status=$?
                log_and_display "${RED}SFTP 列出文件失败！错误: ${raw_backups_list}${NC}" "" "/dev/stderr"
            fi
            raw_backups_list=$(echo "$raw_backups_list" | sed "s|^${target_path}||")
        fi

        if [ "$get_list_status" -ne 0 ]; then
            log_and_display "${YELLOW}${service_display_name} 列表操作失败，跳过清理。${NC}"
            return
        fi

        # Filter for the specific backup file pattern (e.g., my_file_YYYYMMDDHHMMSS.zip)
        mapfile -t backups_array <<< "$(echo "$raw_backups_list" | grep -E '^[a-zA-Z0-9_-]+_[0-9]{14}\.zip$')"
        
        total_backups_found_ref=${#backups_array[@]}

        if [ ${#backups_array[@]} -eq 0 ]; then
            log_and_display "${YELLOW}${service_display_name} 存储中的指定路径 '${target_path}' 未找到备份文件，或工具未正确配置/权限不足。${NC}"
        else
            IFS=$'\n' backups_array=($(sort <<<"${backups_array[*]}")) # Sort by filename (which contains timestamp)
            unset IFS

            if [[ "$RETENTION_POLICY_TYPE" == "count" ]]; then
                log_and_display "${service_display_name} 保留策略: 保留最新 ${RETENTION_VALUE} 个备份。"
                local num_to_delete=$(( ${#backups_array[@]} - RETENTION_VALUE ))
                if [ "$num_to_delete" -gt 0 ]; then
                    log_and_display "${service_display_name}: 发现 ${num_to_delete} 个备份超过保留数量，将删除最旧的 ${num_to_delete} 个。" "${YELLOW}"
                    for (( i=0; i<num_to_delete; i++ )); do
                        local file_to_delete="${backups_array[$i]}"
                        log_and_display "${service_display_name}: 正在删除旧备份: ${file_to_delete}" "${YELLOW}"
                        if delete_file "$service_type" "$file_to_delete"; then
                            deleted_count_ref=$((deleted_count_ref + 1))
                        fi
                    done
                    log_and_display "${GREEN}${service_display_name} 旧备份清理完成。已删除 ${deleted_count_ref} 个文件。${NC}"
                else
                    log_and_display "在 ${service_display_name} 中备份数量 (${total_backups_found_ref} 个) 未超过保留限制 (${RETENTION_VALUE} 个)，无需清理。" "${BLUE}"
                fi
            elif [[ "$RETENTION_POLICY_TYPE" == "days" ]]; then
                log_and_display "${service_display_name} 保留策略: 保留最近 ${RETENTION_VALUE} 天内的备份。"
                local cutoff_timestamp=$(( current_timestamp - RETENTION_VALUE * 24 * 3600 ))
                local files_to_delete=()
                for backup_file in "${backups_array[@]}"; do
                    local backup_date_str=$(echo "$backup_file" | sed -E 's/.*_([0-9]{14})\.zip/\1/')
                    local backup_timestamp=$(date -d "${backup_date_str:0:8} ${backup_date_str:8:2}:${backup_date_str:10:2}:${backup_date_str:12:2}" +%s 2>/dev/null)

                    if [[ "$backup_timestamp" -ne 0 && "$backup_timestamp" -lt "$cutoff_timestamp" ]]; then
                        files_to_delete+=("$backup_file")
                    fi
                done

                if [ ${#files_to_delete[@]} -gt 0 ]; then
                    log_and_display "${service_display_name}: 发现 ${#files_to_delete[@]} 个备份超过 ${RETENTION_VALUE} 天，将进行删除。" "${YELLOW}"
                    for file_to_delete in "${files_to_delete[@]}"; do
                        local delete_timestamp=$(echo "$file_to_delete" | sed -E 's/.*_([0-9]{14})\.zip/\1/')
                        local display_delete_date=$(date -d "${delete_timestamp:0:8} ${delete_timestamp:8:2}:${delete_timestamp:10:2}:${delete_timestamp:12:2}" '+%Y-%m-%d %H:%M:%S' 2>/dev/null)
                        log_and_display "${service_display_name}: 正在删除旧备份: ${file_to_delete} (创建于 ${display_delete_date})" "${YELLOW}"
                        if delete_file "$service_type" "$file_to_delete"; then
                            deleted_count_ref=$((deleted_count_ref + 1))
                        fi
                    done
                    log_and_display "${GREEN}${service_display_name} 旧备份清理完成。已删除 ${deleted_count_ref} 个文件。${NC}"
                else
                    log_and_display "在 ${service_display_name} 中没有超过 ${RETENTION_VALUE} 天的备份，无需清理。" "${BLUE}"
                fi
            fi
        fi
    }

    # Call process_service_retention for each enabled target
    if [[ "$BACKUP_TARGET_S3" == "true" ]]; then
        if [[ -n "$S3_ACCESS_KEY" && -n "$S3_SECRET_KEY" && -n "$S3_ENDPOINT" && -n "$S3_BUCKET_NAME" && -n "$S3_BACKUP_PATH" ]]; then
            process_service_retention "s3" "S3_BACKUP_PATH" total_s3_backups_found deleted_s3_count
        else
            log_and_display "${YELLOW}S3/R2 已启用为备份目标但配置不完整，跳过 S3/R2 备份清理。${NC}"
        fi
    fi

    if [[ "$BACKUP_TARGET_WEBDAV" == "true" ]]; then
        if [[ -n "$WEBDAV_URL" && -n "$WEBDAV_USERNAME" && -n "$WEBDAV_PASSWORD" && -n "$WEBDAV_BACKUP_PATH" ]]; then
            process_service_retention "webdav" "WEBDAV_BACKUP_PATH" total_webdav_backups_found deleted_webdav_count
        else
            log_and_display "${YELLOW}WebDAV 已启用为备份目标但配置不完整，跳过 WebDAV 备份清理。${NC}"
        fi
    fi

    if [[ "$BACKUP_TARGET_FTP" == "true" ]]; then
        if [[ -n "$FTP_HOST" && -n "$FTP_USERNAME" && -n "$FTP_PASSWORD" && -n "$FTP_BACKUP_PATH" ]]; then
            process_service_retention "ftp" "FTP_BACKUP_PATH" total_ftp_backups_found deleted_ftp_count
        else
            log_and_display "${YELLOW}FTP 已启用为备份目标但配置不完整，跳过 FTP 备份清理。${NC}"
        fi
    fi

    if [[ "$BACKUP_TARGET_FTPS" == "true" ]]; then
        if [[ -n "$FTPS_HOST" && -n "$FTPS_USERNAME" && -n "$FTPS_PASSWORD" && -n "$FTPS_BACKUP_PATH" ]]; then
            process_service_retention "ftps" "FTPS_BACKUP_PATH" total_ftps_backups_found deleted_ftps_count
        else
            log_and_display "${YELLOW}FTPS 已启用为备份目标但配置不完整，跳过 FTPS 备份清理。${NC}"
        fi
    fi

    if [[ "$BACKUP_TARGET_SFTP" == "true" ]]; then
        if [[ -n "$SFTP_HOST" && -n "$SFTP_USERNAME" && -n "$SFTP_PASSWORD" && -n "$SFTP_BACKUP_PATH" ]]; then
            process_service_retention "sftp" "SFTP_BACKUP_PATH" total_sftp_backups_found deleted_sftp_count
        else
            log_and_display "${YELLOW}SFTP 已启用为备份目标但配置不完整，跳过 SFTP 备份清理。${NC}"
        fi
    fi

    local retention_summary="保留策略执行完毕。"
    retention_summary+="\nS3/R2: 找到 ${total_s3_backups_found} 个，删除了 ${deleted_s3_count} 个。"
    retention_summary+="\nWebDAV: 找到 ${total_webdav_backups_found} 个，删除了 ${deleted_webdav_count} 个。"
    retention_summary+="\nFTP: 找到 ${total_ftp_backups_found} 个，删除了 ${deleted_ftp_count} 个。"
    retention_summary+="\nFTPS: 找到 ${total_ftps_backups_found} 个，删除了 ${deleted_ftps_count} 个。"
    retention_summary+="\nSFTP: 找到 ${total_sftp_backups_found} 个，删除了 ${deleted_sftp_count} 个。"
    send_telegram_message "*个人自用数据备份：保留策略完成*\n${retention_summary}"
    log_and_display "${BLUE}--- 备份保留策略应用结束 ---${NC}"
}


# [修改] 执行备份上传的核心逻辑 (适应 lftp for SFTP)
# 参数 1: 备份类型 (例如，"手动备份", "自动备份")
perform_backup() {
    local backup_type="$1"
    local readable_time=$(date '+%Y-%m-%d %H:%M:%S')
    local overall_status="失败"
    local overall_succeeded_count=0
    local total_paths_to_backup=${#BACKUP_SOURCE_PATHS_ARRAY[@]}

    log_and_display "${BLUE}--- ${backup_type} 过程开始 ---${NC}"

    local initial_message="*个人自用数据备份：开始 (${backup_type})*\n时间: ${readable_time}\n将备份 ${total_paths_to_backup} 个路径。"
    send_telegram_message "${initial_message}"

    if [ ${#BACKUP_SOURCE_PATHS_ARRAY[@]} -eq 0 ]; then
        log_and_display "${RED}错误：没有设置任何备份源路径。请先通过 '3. 自定义备份路径' 添加路径。${NC}"
        send_telegram_message "*个人自用数据备份：失败*\n原因: 未设置备份源路径。"
        return 1
    fi

    # 遍历每个备份源路径
    for i in "${!BACKUP_SOURCE_PATHS_ARRAY[@]}"; do
        local current_backup_path="${BACKUP_SOURCE_PATHS_ARRAY[$i]}"
        local path_display_name=$(basename "$current_backup_path") # 用于显示友好的路径名
        local timestamp=$(date +%Y%m%d%H%M%S)

        # 清理路径名，使其适合作为文件名 (替换非字母数字下划线连字符为下划线)
        local sanitized_path_name=$(echo "$path_display_name" | sed 's/[^a-zA-Z0-9_-]/_/g')
        # 确保文件名不会以点开头，或者有连续的点
        sanitized_path_name=$(echo "$sanitized_path_name" | sed 's/^\.//; s/\.\./_/g')
        # 如果处理后为空，则使用通用名加索引
        if [[ -z "$sanitized_path_name" ]]; then
            sanitized_path_name="backup_item_${i}"
        fi

        local archive_name="${sanitized_path_name}_${timestamp}.zip"
        local temp_archive_path="${TEMP_DIR}/${archive_name}"
        local backup_file_size="未知"
        local current_path_upload_status="失败" # 记录当前路径的上传状态
        local any_upload_succeeded_for_path="false" # Track if any upload succeeded for this specific path

        log_and_display "${BLUE}--- 正在处理路径 $((i+1))/${total_paths_to_backup}: ${current_backup_path} ---${NC}"

        if [[ ! -d "$current_backup_path" && ! -f "$current_backup_path" ]]; then
            log_and_display "${RED}错误：路径 '$current_backup_path' 无效或不存在，跳过此路径备份。${NC}"
            send_telegram_message "*个人自用数据备份：路径失败*\n路径: \`${current_backup_path}\`\n原因: 路径无效或不存在。"
            continue # 跳过当前路径，继续下一个
        fi

        # --- 压缩文件 ---
        log_and_display "正在压缩路径 '$current_backup_path' 到文件 '$archive_name'..."
        local zip_command_status=1 # 默认为失败
        local zip_output="" # Capture all output (stdout and stderr)

        if [[ -d "$current_backup_path" ]]; then
            # 压缩目录，只包含目录内的内容，不包含父目录本身
            # zip 的 -j 选项用于只存储文件名，不包括目录结构。这里需要包含目录结构。
            # 切换到父目录，然后压缩子目录
            zip_output=$( (cd "$(dirname "$current_backup_path")" && zip -r "$temp_archive_path" "$(basename "$current_backup_path")") 2>&1 )
            zip_command_status=$?
        elif [[ -f "$current_backup_path" ]]; then
            # 压缩单个文件
            zip_output=$(zip "$temp_archive_path" "$current_backup_path" 2>&1)
            zip_command_status=$?
        fi

        if [ "$zip_command_status" -eq 0 ]; then
            log_and_display "${GREEN}文件压缩成功！${NC}"
            if [[ -f "$temp_archive_path" ]]; then
                backup_file_size=$(du -h "$temp_archive_path" | awk '{print $1}')
            else
                backup_file_size="未知 (压缩文件未生成)"
                log_and_display "${RED}警告：压缩成功但未找到生成的临时文件：$temp_archive_path${NC}"
            fi
        else
            log_and_display "${RED}文件压缩失败！请检查路径权限或磁盘空间。错误码: ${zip_command_status}${NC}"
            send_telegram_message "*个人自用数据备份：压缩失败*\n路径: \`${current_backup_path}\`\n文件: \`${archive_name}\`\n原因: 压缩失败，错误码: ${zip_command_status}\n详细错误: \`${zip_output}\`"
            rm -f "$temp_archive_path" 2>/dev/null # 尝试清理失败的临时文件
            continue # 跳过当前路径的上传，继续下一个
        fi

        # Store upload statuses for current path
        local s3_this_upload_status="未尝试"
        local webdav_this_upload_status="未尝试"
        local ftp_this_upload_status="未尝试"
        local ftps_this_upload_status="未尝试"
        local sftp_this_upload_status="未尝试"


        # --- 上传到 S3/R2 ---
        if [[ "$BACKUP_TARGET_S3" == "true" ]]; then
            if [[ -n "$S3_ACCESS_KEY" && -n "$S3_SECRET_KEY" && -n "$S3_ENDPOINT" && -n "$S3_BUCKET_NAME" && -n "$S3_BACKUP_PATH" ]]; then
                log_and_display "正在尝试上传到 S3/R2 存储桶：${S3_BUCKET_NAME}/${S3_BACKUP_PATH}${archive_name}..."
                local s3_upload_output=""
                local s3_upload_status_code=1

                export AWS_ACCESS_KEY_ID="$S3_ACCESS_KEY"
                export AWS_SECRET_ACCESS_KEY="$S3_SECRET_KEY"

                if command -v aws &> /dev/null; then
                    if { s3_upload_output=$(aws s3 cp "$temp_archive_path" "s3://${S3_BUCKET_NAME}/${S3_BACKUP_PATH}${archive_name}" --endpoint-url "$S3_ENDPOINT" 2>&1); } then
                        s3_upload_status_code=0
                    else
                        s3_upload_status_code=$?
                    fi
                elif command -v s3cmd &> /dev/null; then
                    if { s3_upload_output=$(s3cmd put "$temp_archive_path" "s3://${S3_BUCKET_NAME}/${S3_BACKUP_PATH}${archive_name}" 2>&1); } then
                        s3_upload_status_code=0
                    else
                        s3_upload_status_code=$?
                    fi
                fi
                unset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY

                if [ "$s3_upload_status_code" -eq 0 ]; then
                    log_and_display "${GREEN}S3/R2 上传成功！${NC}"
                    s3_this_upload_status="成功"
                    any_upload_succeeded_for_path="true"
                else
                    log_and_display "${RED}S3/R2 上传失败！错误信息: ${s3_upload_output}${NC}"
                    s3_this_upload_status="失败"
                fi
            else
                log_and_display "${RED}S3/R2 已设置为备份目标，但配置不完整。跳过 S3/R2 上传。${NC}"
                s3_this_upload_status="跳过 (配置不完整)"
            fi
        else
            log_and_display "${YELLOW}S3/R2 未设置为备份目标，跳过 S3/R2 上传。${NC}"
            s3_this_upload_status="禁用"
        fi

        # --- 上传到 WebDAV ---
        if [[ "$BACKUP_TARGET_WEBDAV" == "true" ]]; then
            if [[ -n "$WEBDAV_URL" && -n "$WEBDAV_USERNAME" && -n "$WEBDAV_PASSWORD" && -n "$WEBDAV_BACKUP_PATH" ]]; then
                log_and_display "正在尝试上传到 WebDAV 服务器：${WEBDAV_URL%/}/${WEBDAV_BACKUP_PATH}${archive_name}..."
                local webdav_upload_output=""
                local webdav_upload_status_code=1

                if command -v curl &> /dev/null; then
                    if { webdav_upload_output=$(curl -k --user "$WEBDAV_USERNAME:$WEBDAV_PASSWORD" --upload-file "$temp_archive_path" "${WEBDAV_URL%/}/${WEBDAV_BACKUP_PATH}${archive_name}" --fail --no-progress-meter 2>&1); } then
                        webdav_upload_status_code=0
                    else
                        webdav_upload_status_code=$?
                    fi
                fi

                if [ "$webdav_upload_status_code" -eq 0 ]; then
                    log_and_display "${GREEN}WebDAV 上传成功！${NC}"
                    webdav_this_upload_status="成功"
                    any_upload_succeeded_for_path="true"
                else
                    log_and_display "${RED}WebDAV 上传失败！错误信息: ${webdav_upload_output}${NC}"
                    webdav_this_upload_status="失败"
                fi
            else
                log_and_display "${RED}WebDAV 已设置为备份目标，但配置不完整。跳过 WebDAV 上传。${NC}"
                webdav_this_upload_status="跳过 (配置不完整)"
            fi
        else
            log_and_display "${YELLOW}WebDAV 未设置为备份目标，跳过 WebDAV 上传。${NC}"
            webdav_this_upload_status="禁用"
        fi

        # --- FTP 上传 ---
        if [[ "$BACKUP_TARGET_FTP" == "true" ]]; then
            if [[ -n "$FTP_HOST" && -n "$FTP_USERNAME" && -n "$FTP_PASSWORD" && -n "$FTP_BACKUP_PATH" ]]; then
                log_and_display "正在尝试上传到 FTP 服务器：${FTP_HOST}:${FTP_PORT}${FTP_BACKUP_PATH}${archive_name}..."
                local ftp_upload_output=""
                local ftp_upload_status_code=1
                
                if { ftp_upload_output=$(lftp -p "$FTP_PORT" -u "$FTP_USERNAME,$FTP_PASSWORD" "$FTP_HOST" <<EOF
set cmd:long-timeout 3600
set cmd:timeout 300
set ftp:use-passive-mode true
# 创建远端目录 (如果不存在)，-p 选项可以递归创建
mkdir -p "$FTP_BACKUP_PATH"
# 上传文件
put -O "$FTP_BACKUP_PATH" "$temp_archive_path"
quit
EOF
                2>&1); }; then
                    ftp_upload_status_code=0
                else
                    ftp_upload_status_code=$?
                fi

                if [ "$ftp_upload_status_code" -eq 0 ]; then
                    log_and_display "${GREEN}FTP 上传成功！${NC}"
                    ftp_this_upload_status="成功"
                    any_upload_succeeded_for_path="true"
                else
                    log_and_display "${RED}FTP 上传失败！请检查配置或网络连接。错误信息: ${ftp_upload_output}${NC}"
                    ftp_this_upload_status="失败"
                fi
            else
                log_and_display "${RED}FTP 已设置为备份目标，但配置不完整。跳过 FTP 上传。${NC}"
                ftp_this_upload_status="跳过 (配置不完整)"
            fi
        else
            log_and_display "${YELLOW}FTP 未设置为备份目标，跳过 FTP 上传。${NC}"
            ftp_this_upload_status="禁用"
        fi

        # --- FTPS 上传 ---
        if [[ "$BACKUP_TARGET_FTPS" == "true" ]]; then
            if [[ -n "$FTPS_HOST" && -n "$FTPS_USERNAME" && -n "$FTPS_PASSWORD" && -n "$FTPS_BACKUP_PATH" ]]; then
                log_and_display "正在尝试上传到 FTPS 服务器：${FTPS_HOST}:${FTPS_PORT}${FTPS_BACKUP_PATH}${archive_name}..."
                local ftps_upload_output=""
                local ftps_upload_status_code=1
                
                if { ftps_upload_output=$(lftp -p "$FTPS_PORT" -u "$FTPS_USERNAME,$FTPS_PASSWORD" "ftps://$FTPS_HOST" <<EOF
set cmd:long-timeout 3600
set cmd:timeout 300
set ftp:use-passive-mode true
set ftp:ssl-force true
set ftp:ssl-protect-data true
set ssl:verify-certificate no
mkdir -p "$FTPS_BACKUP_PATH"
put -O "$FTPS_BACKUP_PATH" "$temp_archive_path"
quit
EOF
                2>&1); }; then
                    ftps_upload_status_code=0
                else
                    ftps_upload_status_code=$?
                fi

                if [ "$ftps_upload_status_code" -eq 0 ]; then
                    log_and_display "${GREEN}FTPS 上传成功！${NC}"
                    ftps_this_upload_status="成功"
                    any_upload_succeeded_for_path="true"
                else
                    log_and_display "${RED}FTPS 上传失败！请检查配置或网络连接。错误信息: ${ftps_upload_output}${NC}"
                    ftps_this_upload_status="失败"
                fi
            else
                log_and_display "${RED}FTPS 已设置为备份目标，但配置不完整。跳过 FTPS 上传。${NC}"
                ftps_this_upload_status="跳过 (配置不完整)"
            fi
        else
            log_and_display "${YELLOW}FTPS 未设置为备份目标，跳过 FTPS 上传。${NC}"
            ftps_this_upload_status="禁用"
        fi

        # --- [修改] SFTP 上传, 使用 lftp ---
        if [[ "$BACKUP_TARGET_SFTP" == "true" ]]; then
            if [[ -n "$SFTP_HOST" && -n "$SFTP_USERNAME" && -n "$SFTP_PASSWORD" && -n "$SFTP_BACKUP_PATH" ]]; then
                log_and_display "正在尝试上传到 SFTP 服务器：${SFTP_USERNAME}@${SFTP_HOST}:${SFTP_PORT}${SFTP_BACKUP_PATH}${archive_name}..."
                local sftp_upload_output=""
                local sftp_upload_status_code=1
                
                if { sftp_upload_output=$(lftp -p "$SFTP_PORT" -u "$SFTP_USERNAME,$SFTP_PASSWORD" "sftp://$SFTP_HOST" <<EOF
set cmd:long-timeout 3600
set cmd:timeout 300
set sftp:auto-confirm yes
mkdir -p "$SFTP_BACKUP_PATH"
put -O "$SFTP_BACKUP_PATH" "$temp_archive_path"
quit
EOF
                2>&1); }; then
                    sftp_upload_status_code=0
                else
                    sftp_upload_status_code=$?
                fi

                if [ "$sftp_upload_status_code" -eq 0 ]; then
                    log_and_display "${GREEN}SFTP 上传成功！${NC}"
                    sftp_this_upload_status="成功"
                    any_upload_succeeded_for_path="true"
                else
                    log_and_display "${RED}SFTP 上传失败！请检查配置或网络连接。错误信息: ${sftp_upload_output}${NC}"
                    sftp_this_upload_status="失败"
                fi
            else
                log_and_display "${RED}SFTP 已设置为备份目标，但配置不完整。跳过 SFTP 上传。${NC}"
                sftp_this_upload_status="跳过 (配置不完整)"
            fi
        else
            log_and_display "${YELLOW}SFTP 未设置为备份目标，跳过 SFTP 上传。${NC}"
            sftp_this_upload_status="禁用"
        fi

        # 记录当前路径的整体上传状态
        if [[ "$any_upload_succeeded_for_path" == "true" ]]; then
            overall_succeeded_count=$((overall_succeeded_count + 1))
            current_path_upload_status="成功"
        else
            current_path_upload_status="失败"
        fi

        # 发送当前路径的详细 Telegram 通知
        local path_summary_message="*个人自用数据备份：路径完成 (${current_path_upload_status})*\n"
        path_summary_message+="路径: \`${current_backup_path}\`\n"
        path_summary_message+="备份文件: \`${archive_name}\`\n"
        path_summary_message+="文件大小: ${backup_file_size}\n"
        path_summary_message+="S3/R2 上传: ${s3_this_upload_status}"
        if [[ -n "$S3_BUCKET_NAME" && "$s3_this_upload_status" != "禁用" ]]; then path_summary_message+=" (目标: \`${S3_BUCKET_NAME}/${S3_BACKUP_PATH}\`)"; fi
        path_summary_message+="\n"
        path_summary_message+="WebDAV 上传: ${webdav_this_upload_status}"
        if [[ -n "$WEBDAV_URL" && "$webdav_this_upload_status" != "禁用" ]]; then path_summary_message+=" (目标: \`${WEBDAV_URL%/}/${WEBDAV_BACKUP_PATH}\`)"; fi
        path_summary_message+="\n"
        path_summary_message+="FTP 上传: ${ftp_this_upload_status}"
        if [[ -n "$FTP_HOST" && "$ftp_this_upload_status" != "禁用" ]]; then path_summary_message+=" (目标: \`${FTP_HOST}:${FTP_PORT}${FTP_BACKUP_PATH}\`)"; fi
        path_summary_message+="\n"
        path_summary_message+="FTPS 上传: ${ftps_this_upload_status}"
        if [[ -n "$FTPS_HOST" && "$ftps_this_upload_status" != "禁用" ]]; then path_summary_message+=" (目标: \`${FTPS_HOST}:${FTPS_PORT}${FTPS_BACKUP_PATH}\`)"; fi
        path_summary_message+="\n"
        path_summary_message+="SFTP 上传: ${sftp_this_upload_status}"
        if [[ -n "$SFTP_HOST" && "$sftp_this_upload_status" != "禁用" ]]; then path_summary_message+=" (目标: \`${SFTP_HOST}:${SFTP_PORT}${SFTP_BACKUP_PATH}\`)"; fi
        send_telegram_message "${path_summary_message}"

        # 清理当前路径的临时压缩文件
        if [[ -f "$temp_archive_path" ]]; then
            log_and_display "正在清理临时压缩文件：$temp_archive_path"
            rm -f "$temp_archive_path"
            if [ $? -eq 0 ]; then
                log_and_display "${GREEN}临时文件清理完成。${NC}"
            else
                log_and_display "${RED}临时文件清理失败。${NC}"
            fi
        fi
    done # 结束所有路径的循环

    # 根据所有路径的备份结果确定整体状态
    if [ "$overall_succeeded_count" -eq "$total_paths_to_backup" ] && [ "$total_paths_to_backup" -gt 0 ]; then
        overall_status="全部成功"
    elif [ "$overall_succeeded_count" -gt 0 ]; then
        overall_status="部分成功"
    elif [ "$total_paths_to_backup" -eq 0 ]; then
        overall_status="未执行 (无备份路径)"
    else
        overall_status="全部失败"
    fi

    log_and_display "${BLUE}--- ${backup_type} 过程结束 ---${NC}"

    # 如果是自动备份，更新上次自动备份时间戳
    if [[ "$backup_type" == "自动备份 (Cron)" ]]; then
        LAST_AUTO_BACKUP_TIMESTAMP=$(date +%s)
        save_config # 保存更新后的时间戳 (这也会保存当前凭证)
        log_and_display "已更新上次自动备份时间戳：$(date -d @$LAST_AUTO_BACKUP_TIMESTAMP '+%Y-%m-%d %H:%M:%S')" "${BLUE}"
    fi

    # 发送最终的整体 Telegram 通知
    local final_overall_message="*个人自用数据备份：总览 (${overall_status})*\n"
    final_overall_message+="时间: ${readable_time}\n"
    final_overall_message+="类型: ${backup_type}\n"
    final_overall_message+="总路径数: ${total_paths_to_backup}\n"
    final_overall_message+="成功备份路径数: ${overall_succeeded_count}\n"
    send_telegram_message "${final_overall_message}"

    # 只有在至少一个上传尝试成功后才应用保留策略
    # 注意：保留策略现在会处理新命名的文件
    if [[ "$overall_succeeded_count" -gt 0 ]]; then
        apply_retention_policy
    else
        log_and_display "${YELLOW}由于没有成功的备份上传，跳过保留策略的执行。${NC}"
    fi
}

# 99. 卸载脚本 (保持不变)
uninstall_script() {
    display_header
    echo -e "${RED}=== 99. 卸载脚本 ===${NC}"
    log_and_display "${RED}警告：您确定要卸载脚本吗？这将删除所有脚本文件、配置文件和日志文件。（y/N）${NC}"
    read -rp "请确认 (y/N): " confirm

    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        log_and_display "${RED}开始卸载脚本...${NC}"
        local script_path="$(readlink -f "$0")" # 获取脚本的真实路径

        log_and_display "删除脚本文件：$script_path"
        rm -f "$script_path" 2>/dev/null

        if [[ -f "$CONFIG_FILE" ]]; then
            log_and_display "删除配置文件：$CONFIG_FILE"
            rm -f "$CONFIG_FILE" 2>/dev/null
        fi

        if [[ -d "$CONFIG_DIR" ]] && [ -z "$(ls -A "$CONFIG_DIR")" ]; then
            log_and_display "删除空配置目录：$CONFIG_DIR"
            rmdir "$CONFIG_DIR" 2>/dev/null
        fi

        if [[ -f "$LOG_FILE" ]]; then
            log_and_display "删除日志文件：$LOG_FILE"
            rm -f "$LOG_FILE" 2>/dev/null
        fi

        if [[ -d "$LOG_DIR" ]] && [ -z "$(ls -A "$LOG_DIR")" ]; then
            log_and_display "删除空日志目录：$LOG_DIR"
            rmdir "$LOG_DIR" 2>/dev/null
        fi

        log_and_display "${YELLOW}提示：如果此脚本是通过别名或放置在 PATH 中的文件启动的，您可能需要手动删除它们。${NC}"
        log_and_display "${GREEN}脚本卸载完成。${NC}"
        exit 0
    else
        log_and_display "取消卸载。" "${BLUE}"
    fi
    press_enter_to_continue
}

# --- 主菜单 ---
show_main_menu() {
    display_header
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━ 功能选项 ━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "  1. ${YELLOW}自动备份设定${NC} (当前间隔: ${AUTO_BACKUP_INTERVAL_DAYS} 天)${NC}"
    echo -e "  2. ${YELLOW}手动备份${NC}"
    echo -e "  3. ${YELLOW}自定义备份路径${NC} (当前数量: ${#BACKUP_SOURCE_PATHS_ARRAY[@]} 个)${NC}" # 显示路径数量
    echo -e "  4. ${YELLOW}压缩包格式${NC} (当前支持: ZIP)${NC}"
    echo -e "  5. ${YELLOW}云存储设定${NC} (支持: S3/R2, WebDAV, FTP, FTPS, SFTP)${NC}"
    echo -e "  6. ${YELLOW}消息通知设定${NC} (Telegram)${NC}"
    echo -e "  7. ${YELLOW}设置备份保留策略${NC} (云端)${NC}"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "  0. ${RED}退出脚本${NC}"
    echo -e "  99. ${RED}卸载脚本${NC}"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
}

# 处理菜单选择
process_menu_choice() {
    local choice
    read -rp "请输入选项: " choice
    log_and_display "用户选择: $choice"

    case $choice in
        1) set_auto_backup_interval ;;
        2) manual_backup ;;
        3) set_backup_path ;; # 调用新的多路径管理函数
        4) display_compression_info ;;
        5) set_cloud_storage ;;
        6) set_telegram_notification ;;
        7) set_retention_policy ;;
        0)
            log_and_display "${GREEN}感谢使用，再见！${NC}"
            exit 0
            ;;
        99) uninstall_script ;;
        *)
            log_and_display "${RED}无效的选项，请重新输入。${NC}"
            press_enter_to_continue
            ;;
    esac
}

# [修改] 检查是否应该运行自动备份 (移除 sshpass 检查)
check_auto_backup() {
    load_config # 确保加载最新配置

    local current_timestamp=$(date +%s)
    local interval_seconds=$(( AUTO_BACKUP_INTERVAL_DAYS * 24 * 3600 )) # 将天数转换为秒

    # 检查是否有至少一个备份路径
    if [ ${#BACKUP_SOURCE_PATHS_ARRAY[@]} -eq 0 ]; then
        log_and_display "${RED}自动备份失败：没有设置任何备份源路径。请通过主菜单设置。${NC}"
        send_telegram_message "*个人自用数据备份：自动备份失败*\n原因: 未设置备份源路径。"
        return 1
    fi

    # 检查是否有至少一个启用的备份目标
    local any_target_enabled="false"
    if [[ "$BACKUP_TARGET_S3" == "true" && -n "$S3_ACCESS_KEY" && -n "$S3_SECRET_KEY" && -n "$S3_ENDPOINT" && -n "$S3_BUCKET_NAME" && -n "$S3_BACKUP_PATH" ]]; then any_target_enabled="true"; fi
    if [[ "$BACKUP_TARGET_WEBDAV" == "true" && -n "$WEBDAV_URL" && -n "$WEBDAV_USERNAME" && -n "$WEBDAV_PASSWORD" && -n "$WEBDAV_BACKUP_PATH" ]]; then any_target_enabled="true"; fi
    if [[ "$BACKUP_TARGET_FTP" == "true" && -n "$FTP_HOST" && -n "$FTP_USERNAME" && -n "$FTP_PASSWORD" && -n "$FTP_BACKUP_PATH" ]]; then any_target_enabled="true"; fi
    if [[ "$BACKUP_TARGET_FTPS" == "true" && -n "$FTPS_HOST" && -n "$FTPS_USERNAME" && -n "$FTPS_PASSWORD" && -n "$FTPS_BACKUP_PATH" ]]; then any_target_enabled="true"; fi
    if [[ "$BACKUP_TARGET_SFTP" == "true" && -n "$SFTP_HOST" && -n "$SFTP_USERNAME" && -n "$SFTP_PASSWORD" && -n "$SFTP_BACKUP_PATH" ]]; then any_target_enabled="true"; fi


    if [[ "$any_target_enabled" == "false" ]]; then
        log_and_display "${RED}自动备份失败：没有启用或配置完整的云存储目标。请通过 '5. 云存储设定' 进行配置。${NC}"
        send_telegram_message "*个人自用数据备份：自动备份失败*\n原因: 未启用或配置完整的云存储目标。"
        return 1
    fi


    if [[ "$LAST_AUTO_BACKUP_TIMESTAMP" -eq 0 ]]; then
        log_and_display "首次自动备份，或上次自动备份时间未记录，立即执行。" "${YELLOW}"
        perform_backup "自动备份 (Cron)"
    elif (( current_timestamp - LAST_AUTO_BACKUP_TIMESTAMP >= interval_seconds )); then
        log_and_display "距离上次自动备份已超过 ${AUTO_BACKUP_INTERVAL_DAYS} 天 (${interval_seconds} 秒)，执行自动备份。" "${BLUE}"
        perform_backup "自动备份 (Cron)"
    else
        local next_backup_time=$(( LAST_AUTO_BACKUP_TIMESTAMP + interval_seconds ))
        local remaining_seconds=$(( next_backup_time - current_timestamp ))
        local remaining_days=$(( remaining_seconds / 86400 ))
        local remaining_hours=$(( (remaining_seconds % 86400) / 3600 ))
        log_and_display "未到自动备份时间。距离下次备份还有约 ${remaining_days} 天 ${remaining_hours} 小时。" "${YELLOW}"
    fi
}

# --- 脚本入口点 ---
main() {
    # 创建一个安全的临时目录，用于存放压缩文件
    TEMP_DIR=$(mktemp -d -t personal_backup_XXXXXX)
    if [ ! -d "$TEMP_DIR" ]; then
        log_and_display "${RED}错误：无法创建临时目录。请检查权限或磁盘空间。${NC}"
        exit 1
    fi
    log_and_display "临时目录已创建: $TEMP_DIR" "${BLUE}"


    load_config # 脚本启动时加载配置

    # 如果直接从 cron 任务调用带有特定参数
    if [[ "$1" == "check_auto_backup" ]]; then
        log_and_display "由 Cron 任务触发自动备份检查。" "${BLUE}"
        check_auto_backup
        exit 0
    fi

    # 在交互模式下检查依赖项 (仅当不是 cron 任务时)
    if ! check_dependencies; then
        log_and_display "${RED}脚本无法运行，因为缺少必要的依赖项。请按照提示安装。${NC}"
        exit 1
    fi

    while true; do
        show_main_menu
        process_menu_choice
    done
}

# 执行主函数
main "$@"
