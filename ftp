#!/bin/bash
set -e # Exit immediately if a command exits with a non-zero status.

# 脚本全局配置
SCRIPT_NAME="个人自用数据备份"
# 使用 XDG Base Directory Specification，将配置文件和日志文件放在标准位置
# 如果您不熟悉 XDG，可以继续使用 $HOME/.personal_backup_config
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/personal_backup"
LOG_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/personal_backup"
CONFIG_FILE="$CONFIG_DIR/config"
LOG_FILE="$LOG_DIR/log.txt"

# 默认值 (如果配置文件未找到)
# BACKUP_SOURCE_PATH="" # 已被 BACKUP_SOURCE_PATHS_ARRAY 取代
declare -a BACKUP_SOURCE_PATHS_ARRAY=() # 新增：要备份的源路径数组
BACKUP_SOURCE_PATHS_STRING="" # 新增：用于配置文件保存的路径字符串，使用特殊分隔符连接

AUTO_BACKUP_INTERVAL_DAYS=7 # 默认自动备份间隔天数 (例如，7 天 = 1 周)
LAST_AUTO_BACKUP_TIMESTAMP=0 # 上次自动备份的 Unix 时间戳

# 备份保留策略默认值
RETENTION_POLICY_TYPE="none" # "none", "count", "days"
RETENTION_VALUE=0           # 要保留的备份数量或天数

# 云存储凭证变量 (现在从配置文件加载/保存，更方便)
S3_ACCESS_KEY=""
S3_SECRET_KEY=""
S3_ENDPOINT="" # Cloudflare R2 端点，例如："https://<ACCOUNT_ID>.r2.cloudflarestorage.com"
S3_BUCKET_NAME=""
S3_BACKUP_PATH="" # S3/R2 备份的目标路径

WEBDAV_URL=""
WEBDAV_USERNAME=""
WEBDAV_PASSWORD=""
WEBDAV_BACKUP_PATH="" # WebDAV 备份的目标路径

# --- 新增 FTP/FTPS/SFTP 凭证变量 ---
FTP_HOST=""
FTP_USERNAME=""
FTP_PASSWORD=""
FTP_PORT=21 # 默认 FTP 端口
FTP_BACKUP_PATH=""

FTPS_HOST=""
FTPS_USERNAME=""
FTPS_PASSWORD=""
FTPS_PORT=21 # 默认 FTPS 端口
FTPS_BACKUP_PATH=""

SFTP_HOST=""
SFTP_USERNAME=""
SFTP_PASSWORD="" # SFTP 建议使用 SSH 密钥，但这里也支持密码
SFTP_PORT=22 # 默认 SFTP 端口
SFTP_BACKUP_PATH=""

# 备份目标标志
BACKUP_TARGET_S3="false"     # 是否启用 S3/R2 备份 (true/false)
BACKUP_TARGET_WEBDAV="false" # 是否启用 WebDAV 备份 (true/false)
BACKUP_TARGET_FTP="false"    # 是否启用 FTP 备份 (true/false)
BACKUP_TARGET_FTPS="false"   # 是否启用 FTPS 备份 (true/false)
BACKUP_TARGET_SFTP="false"   # 是否启用 SFTP 备份 (true/false)

# Telegram 通知变量 (现在从配置文件加载/保存)
TELEGRAM_BOT_TOKEN=""
TELEGRAM_CHAT_ID=""

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # 无颜色 - 重置为默认终端颜色

# 用于存储临时压缩文件的目录，使用 mktemp 创建一个安全的临时目录
TEMP_DIR=""

# --- 辅助函数 ---

# 确保在脚本退出时清理临时目录
cleanup_temp_dir() {
    if [[ -n "$TEMP_DIR" && -d "$TEMP_DIR" ]]; then
        rm -rf "$TEMP_DIR"
        # 不使用 log_and_display，避免在退出时产生过多日志
        echo "$(date '+%Y-%m-%d %H:%M:%S') - 清理临时目录: $TEMP_DIR" >> "$LOG_FILE"
    fi
}

# 注册清理函数，以便在脚本退出时运行 (即使发生错误)
trap cleanup_temp_dir EXIT

# 清屏
clear_screen() {
    clear
}

# 显示脚本头部
display_header() {
    clear_screen
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${GREEN}      $SCRIPT_NAME        ${NC}"
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
}

# 显示消息并记录到日志
# 参数 1: 消息内容
# 参数 2: 颜色代码 (可选)
# 参数 3: 输出目的地 (可选，默认为 /dev/stdout。使用 /dev/stderr 将输出到标准错误)
log_and_display() {
    local message="$1"
    local color="$2"
    local output_destination="${3:-/dev/stdout}" # Default to stdout
    local plain_message
    # Strip ANSI escape codes from the message for logging
    plain_message=$(echo -e "$message" | sed 's/\x1b\[[0-9;]*m//g')

    # Log to file with timestamp
    echo "$(date '+%Y-%m-%d %H:%M:%S') - ${plain_message}" >> "$LOG_FILE"

    # Display to specified destination with optional color
    if [[ -n "$color" ]]; then
        echo -e "$color$message$NC" > "$output_destination"
    else
        echo -e "$message" > "$output_destination"
    fi
}

# 等待用户按 Enter 键继续
press_enter_to_continue() {
    echo ""
    log_and_display "${BLUE}按 Enter 键继续...${NC}" ""
    read -r
    clear_screen
}

# --- 配置保存和加载 ---

# 保存配置到文件
save_config() {
    # 确保配置目录存在
    mkdir -p "$CONFIG_DIR" 2>/dev/null
    if [ ! -d "$CONFIG_DIR" ]; then
        log_and_display "${RED}错误：无法创建配置目录 $CONFIG_DIR，请检查权限。${NC}"
        return 1
    fi

    # 将数组转换为字符串，使用 ;; 作为分隔符，确保路径中不太可能出现
    BACKUP_SOURCE_PATHS_STRING=$(IFS=';;'; echo "${BACKUP_SOURCE_PATHS_ARRAY[*]}")

    # 使用原子写入，避免部分写入导致文件损坏
    {
        echo "BACKUP_SOURCE_PATHS_STRING=\"$BACKUP_SOURCE_PATHS_STRING\"" # 保存路径字符串
        echo "AUTO_BACKUP_INTERVAL_DAYS=$AUTO_BACKUP_INTERVAL_DAYS"
        echo "LAST_AUTO_BACKUP_TIMESTAMP=$LAST_AUTO_BACKUP_TIMESTAMP"
        echo "RETENTION_POLICY_TYPE=\"$RETENTION_POLICY_TYPE\""
        echo "RETENTION_VALUE=$RETENTION_VALUE"

        # 保存敏感凭证
        echo "S3_ACCESS_KEY=\"$S3_ACCESS_KEY\""
        echo "S3_SECRET_KEY=\"$S3_SECRET_KEY\""
        echo "S3_ENDPOINT=\"$S3_ENDPOINT\""
        echo "S3_BUCKET_NAME=\"$S3_BUCKET_NAME\""
        echo "S3_BACKUP_PATH=\"$S3_BACKUP_PATH\"" # 保存 S3/R2 备份路径

        echo "WEBDAV_URL=\"$WEBDAV_URL\""
        echo "WEBDAV_USERNAME=\"$WEBDAV_USERNAME\""
        echo "WEBDAV_PASSWORD=\"$WEBDAV_PASSWORD\""
        echo "WEBDAV_BACKUP_PATH=\"$WEBDAV_BACKUP_PATH\"" # 保存 WebDAV 备份路径

        # --- 新增 FTP/FTPS/SFTP 配置保存 ---
        echo "FTP_HOST=\"$FTP_HOST\""
        echo "FTP_USERNAME=\"$FTP_USERNAME\""
        echo "FTP_PASSWORD=\"$FTP_PASSWORD\""
        echo "FTP_PORT=$FTP_PORT"
        echo "FTP_BACKUP_PATH=\"$FTP_BACKUP_PATH\""

        echo "FTPS_HOST=\"$FTPS_HOST\""
        echo "FTPS_USERNAME=\"$FTPS_USERNAME\""
        echo "FTPS_PASSWORD=\"$FTPS_PASSWORD\""
        echo "FTPS_PORT=$FTPS_PORT"
        echo "FTPS_BACKUP_PATH=\"$FTPS_BACKUP_PATH\""

        echo "SFTP_HOST=\"$SFTP_HOST\""
        echo "SFTP_USERNAME=\"$SFTP_USERNAME\""
        echo "SFTP_PASSWORD=\"$SFTP_PASSWORD\""
        echo "SFTP_PORT=$SFTP_PORT"
        echo "SFTP_BACKUP_PATH=\"$SFTP_BACKUP_PATH\""

        echo "BACKUP_TARGET_S3=\"$BACKUP_TARGET_S3\"" # 保存备份目标标志
        echo "BACKUP_TARGET_WEBDAV=\"$BACKUP_TARGET_WEBDAV\"" # 保存备份目标标志
        echo "BACKUP_TARGET_FTP=\"$BACKUP_TARGET_FTP\"" # 保存 FTP 备份目标标志
        echo "BACKUP_TARGET_FTPS=\"$BACKUP_TARGET_FTPS\"" # 保存 FTPS 备份目标标志
        echo "BACKUP_TARGET_SFTP=\"$BACKUP_TARGET_SFTP\"" # 保存 SFTP 备份目标标志

        echo "TELEGRAM_BOT_TOKEN=\"$TELEGRAM_BOT_TOKEN\""
        echo "TELEGRAM_CHAT_ID=\"$TELEGRAM_CHAT_ID\""
    } > "$CONFIG_FILE"

    log_and_display "配置已保存到 $CONFIG_FILE"
    # 重要：立即设置配置文件为安全权限
    chmod 600 "$CONFIG_FILE" 2>/dev/null # 抑制 chmod 失败时的错误 (例如，在只读文件系统上)
    log_and_display "${YELLOW}已将配置文件 $CONFIG_FILE 权限设置为 600 (只有所有者可读写)，请确保您的系统安全。${NC}"
}

# 从文件加载配置
load_config() {
    # 确保日志目录存在
    mkdir -p "$LOG_DIR" 2>/dev/null
    if [ ! -d "$LOG_DIR" ]; then
        echo "$(date '+%Y-%m-%d %H:%M:%S') - 错误：无法创建日志目录 $LOG_DIR，请检查权限。" | tee -a "$LOG_FILE"
        return 1
    fi

    if [[ -f "$CONFIG_FILE" ]]; then
        # 检查权限，如果不是 600，则发出警告并尝试设置
        current_perms=$(stat -c "%a" "$CONFIG_FILE" 2>/dev/null)
        if [[ "$current_perms" != "600" ]]; then
            log_and_display "${YELLOW}警告：配置文件 $CONFIG_FILE 权限不安全 (${current_perms})，建议设置为 600。正在尝试设置...${NC}"
            chmod 600 "$CONFIG_FILE" 2>/dev/null
            if [ $? -ne 0 ]; then
                log_and_display "${RED}错误：无法将配置文件 $CONFIG_FILE 权限设置为 600，请手动检查。${NC}"
            else
                log_and_display "${GREEN}已将配置文件 $CONFIG_FILE 权限设置为 600。${NC}"
            fi
        fi
        source "$CONFIG_FILE"
        log_and_display "配置已从 $CONFIG_FILE 加载。" "${BLUE}"

        # 将字符串解析回数组
        if [[ -n "$BACKUP_SOURCE_PATHS_STRING" ]]; then
            IFS=';;' read -r -a BACKUP_SOURCE_PATHS_ARRAY <<< "$BACKUP_SOURCE_PATHS_STRING"
        else
            BACKUP_SOURCE_PATHS_ARRAY=()
        fi
    else
        log_and_display "未找到配置文件 $CONFIG_FILE，将使用默认配置。首次运行或配置已被删除。" "${YELLOW}"
        # 确保新变量在未找到配置时也初始化为默认值
        BACKUP_SOURCE_PATHS_ARRAY=()
        BACKUP_SOURCE_PATHS_STRING=""
        S3_BACKUP_PATH=""
        WEBDAV_BACKUP_PATH=""
        FTP_BACKUP_PATH=""
        FTPS_BACKUP_PATH=""
        SFTP_BACKUP_PATH=""
        BACKUP_TARGET_S3="false"
        BACKUP_TARGET_WEBDAV="false"
        BACKUP_TARGET_FTP="false"
        BACKUP_TARGET_FTPS="false"
        BACKUP_TARGET_SFTP="false"
    fi
}

# --- 核心功能 ---

# 检查所需依赖项
check_dependencies() {
    local missing_deps=()
    command -v zip &> /dev/null || missing_deps+=("zip")
    # 检查 realpath 命令是否存在，用于规范化路径
    command -v realpath &> /dev/null || missing_deps+=("realpath")


    # 仅当 S3/R2 凭证在配置中设置时才检查 S3/R2 依赖项
    if [[ -n "$S3_ACCESS_KEY" && -n "$S3_SECRET_KEY" && -n "$S3_ENDPOINT" && -n "$S3_BUCKET_NAME" ]]; then
        # 优先检测 awscli，其次 s3cmd
        if ! (command -v aws &> /dev/null || command -v s3cmd &> /dev/null); then
            missing_deps+=("awscli 或 s3cmd (用于S3/R2)")
        fi
    fi
    # 仅当 WebDAV 凭证在配置中设置时才检查 WebDAV 依赖项
    if [[ -n "$WEBDAV_URL" && -n "$WEBDAV_USERNAME" && -n "$WEBDAV_PASSWORD" ]]; then
        command -v curl &> /dev/null || missing_deps+=("curl (用于WebDAV)")
    fi
    # 仅当 FTP/FTPS 凭证在配置中设置时才检查 lftp 依赖项
    if [[ -n "$FTP_HOST" && -n "$FTP_USERNAME" && -n "$FTP_PASSWORD" ]] || \
       [[ -n "$FTPS_HOST" && -n "$FTPS_USERNAME" && -n "$FTPS_PASSWORD" ]]; then
        command -v lftp &> /dev/null || missing_deps+=("lftp (用于FTP/FTPS)")
    fi
    # 仅当 SFTP 凭证在配置中设置时才检查 sftp 和 sshpass 依赖项
    if [[ -n "$SFTP_HOST" && -n "$SFTP_USERNAME" && -n "$SFTP_PASSWORD" ]]; then
        command -v sftp &> /dev/null || missing_deps+=("sftp (用于SFTP)")
        command -v sshpass &> /dev/null || missing_deps+=("sshpass (建议安装用于SFTP密码认证)")
    fi

    # 仅当 Telegram 凭证在配置中设置时才检查 curl 和 jq 依赖项
    if [[ -n "$TELEGRAM_BOT_TOKEN" && -n "$TELEGRAM_CHAT_ID" ]]; then
        command -v curl &> /dev/null || missing_deps+=("curl (用于Telegram)")
        command -v jq &> /dev/null || missing_deps+=("jq (用于Telegram消息URL编码)")
    fi

    if [ ${#missing_deps[@]} -gt 0 ]; then
        log_and_display "${RED}检测到以下依赖项缺失，请安装后重试：${missing_deps[*]}${NC}"
        log_and_display "例如 (Debian/Ubuntu): sudo apt update && sudo apt install zip awscli curl jq realpath lftp openssh-client sshpass" "${YELLOW}"
        log_and_display "例如 (CentOS/RHEL): sudo yum install zip awscli curl jq realpath lftp openssh-clients sshpass" "${YELLOW}"
        press_enter_to_continue
        return 1
    fi
    return 0
}

# 发送 Telegram 消息的函数
# 参数 1: 消息内容
send_telegram_message() {
    local message_content="$1"
    if [[ -z "$TELEGRAM_BOT_TOKEN" || -z "$TELEGRAM_CHAT_ID" ]]; then
        log_and_display "${YELLOW}Telegram 通知未配置，跳过发送消息。${NC}" "" "/dev/stderr"
        return 1
    fi

    # 再次检查 curl 和 jq 是否存在
    if ! command -v curl &> /dev/null; then
        log_and_display "${RED}错误：发送 Telegram 消息需要 'curl' 命令，但未找到。${NC}" "" "/dev/stderr"
        return 1
    fi

    local encoded_message=""
    if command -v jq &> /dev/null; then
        encoded_message=$(printf %s "$message_content" | jq -sRr @uri)
    else
        log_and_display "${YELLOW}警告：未找到 'jq'，将使用简单的 URL 编码，可能不完全可靠。${NC}" "" "/dev/stderr"
        # 备用简单编码 (对于复杂字符不太可靠)
        encoded_message=$(printf %s "$message_content" | sed 's/[^a-zA-Z0-9._~-]/%&/g; s/ /%20/g')
    fi

    log_and_display "正在发送 Telegram 消息..." "" "/dev/stderr"
    if curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
        -d "chat_id=${TELEGRAM_CHAT_ID}" \
        -d "text=${encoded_message}" \
        -d "parse_mode=Markdown" > /dev/null; then
        log_and_display "${GREEN}Telegram 消息发送成功。${NC}" "" "/dev/stderr"
    else
        log_and_display "${RED}Telegram 消息发送失败，请检查 Bot Token 和 Chat ID，或网络连接。${NC}" "" "/dev/stderr"
    fi
}


# 1. 设置自动备份间隔
set_auto_backup_interval() {
    display_header
    echo -e "${BLUE}=== 1. 自动备份设定 ===${NC}"
    echo "当前自动备份间隔: ${AUTO_BACKUP_INTERVAL_DAYS} 天"
    echo ""
    read -rp "请输入新的自动备份间隔时间（天数，最小1天，例如 7 为 1 周）: " interval_input

    if [[ "$interval_input" =~ ^[0-9]+$ ]] && [ "$interval_input" -ge 1 ]; then
        AUTO_BACKUP_INTERVAL_DAYS="$interval_input"
        save_config
        log_and_display "${GREEN}自动备份间隔已成功设置为：${AUTO_BACKUP_INTERVAL_DAYS} 天。${NC}"
        log_and_display "${YELLOW}提示：现在您只需确保 Cron Job 每天运行此脚本一次。脚本会根据您设置的间隔自动判断是否执行备份。${NC}"
        log_and_display "${YELLOW}Cron Job 条目示例 (请将 /path/to/your_script.sh 替换为实际路径):${NC}"
        log_and_display "${YELLOW}0 0 * * * bash /path/to/your_script.sh check_auto_backup > /dev/null 2>&1${NC}" # 每天午夜运行
    else
        log_and_display "${RED}输入无效，请输入一个大于等于 1 的整数。${NC}"
    fi
    press_enter_to_continue
}

# 2. 手动备份
manual_backup() {
    display_header
    echo -e "${BLUE}=== 2. 手动备份 ===${NC}"
    # 检查是否有至少一个备份路径
    if [ ${#BACKUP_SOURCE_PATHS_ARRAY[@]} -eq 0 ]; then
        log_and_display "${RED}错误：没有设置任何备份源路径。请先通过 '3. 自定义备份路径' 添加路径。${NC}"
        press_enter_to_continue
        return 1
    fi
    log_and_display "您选择了手动备份，立即执行备份上传。" "${GREEN}"
    perform_backup "手动备份"
    press_enter_to_continue
}

# --- 修改后的 3. 自定义备份路径 ---
add_backup_path() {
    display_header
    echo -e "${BLUE}=== 添加备份路径 ===${NC}"
    read -rp "请输入要备份的文件或文件夹的绝对路径（例如 /home/user/mydata 或 /etc/nginx/nginx.conf）: " path_input

    local resolved_path=$(realpath -q "$path_input" 2>/dev/null)

    if [[ -z "$resolved_path" ]]; then
        log_and_display "${RED}错误：输入的路径无效或不存在。${NC}"
    elif [[ ! -d "$resolved_path" && ! -f "$resolved_path" ]]; then
        log_and_display "${RED}错误：输入的路径 '$resolved_path' 不存在或不是有效的文件/目录。${NC}"
    else
        # 检查是否已存在
        local found=false
        for p in "${BACKUP_SOURCE_PATHS_ARRAY[@]}"; do
            if [[ "$p" == "$resolved_path" ]]; then
                found=true
                break
            fi
        done

        if "$found"; then
            log_and_display "${YELLOW}该路径 '$resolved_path' 已存在于备份列表中。${NC}"
        else
            BACKUP_SOURCE_PATHS_ARRAY+=("$resolved_path")
            save_config
            log_and_display "${GREEN}备份路径 '$resolved_path' 已成功添加。${NC}"
        fi
    fi
    press_enter_to_continue
}

view_and_manage_backup_paths() {
    while true; do
        display_header
        echo -e "${BLUE}=== 查看/管理备份路径 ===${NC}"
        if [ ${#BACKUP_SOURCE_PATHS_ARRAY[@]} -eq 0 ]; then
            log_and_display "${YELLOW}当前没有设置任何备份路径。${NC}"
            press_enter_to_continue
            break
        fi

        echo "当前备份路径列表:"
        for i in "${!BACKUP_SOURCE_PATHS_ARRAY[@]}"; do
            echo "  $((i+1)). ${BACKUP_SOURCE_PATHS_ARRAY[$i]}"
        done
        echo ""
        echo "1. 修改现有路径"
        echo "2. 删除路径"
        echo "0. 返回自定义备份路径菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"
        read -rp "请输入选项: " sub_choice

        case $sub_choice in
            1) # 修改路径
                read -rp "请输入要修改的路径序号: " path_index
                if [[ "$path_index" =~ ^[0-9]+$ ]] && [ "$path_index" -ge 1 ] && [ "$path_index" -le ${#BACKUP_SOURCE_PATHS_ARRAY[@]} ]; then
                    local current_path="${BACKUP_SOURCE_PATHS_ARRAY[$((path_index-1))]}"
                    read -rp "您正在修改路径 '${current_path}'。请输入新的绝对路径: " new_path_input

                    local resolved_new_path=$(realpath -q "$new_path_input" 2>/dev/null)

                    if [[ -z "$resolved_new_path" ]]; then
                        log_and_display "${RED}错误：输入的路径无效或不存在。${NC}"
                    elif [[ ! -d "$resolved_new_path" && ! -f "$resolved_new_path" ]]; then
                        log_and_display "${RED}错误：输入的路径 '$resolved_new_path' 不存在或不是有效的文件/目录。${NC}"
                    else
                        # 移除目录的尾部斜杠，但保留文件路径的完整性
                        if [[ -d "$resolved_new_path" ]]; then
                            resolved_new_path="${resolved_new_path%/}"
                        fi
                        BACKUP_SOURCE_PATHS_ARRAY[$((path_index-1))]="$resolved_new_path"
                        save_config
                        log_and_display "${GREEN}路径已成功修改为：${resolved_new_path}${NC}"
                    fi
                else
                    log_and_display "${RED}无效的路径序号。${NC}"
                fi
                press_enter_to_continue
                ;;
            2) # 删除路径
                read -rp "请输入要删除的路径序号: " path_index
                if [[ "$path_index" =~ ^[0-9]+$ ]] && [ "$path_index" -ge 1 ] && [ "$path_index" -le ${#BACKUP_SOURCE_PATHS_ARRAY[@]} ]; then
                    log_and_display "${YELLOW}警告：您确定要删除路径 '${BACKUP_SOURCE_PATHS_ARRAY[$((path_index-1))]}' 吗？(y/N)${NC}"
                    read -rp "请确认: " confirm_delete
                    if [[ "$confirm_delete" =~ ^[Yy]$ ]]; then
                        # 从数组中删除元素
                        unset 'BACKUP_SOURCE_PATHS_ARRAY[$((path_index-1))]'
                        BACKUP_SOURCE_PATHS_ARRAY=("${BACKUP_SOURCE_PATHS_ARRAY[@]}") # 重新索引数组
                        save_config
                        log_and_display "${GREEN}路径已成功删除。${NC}"
                    else
                        log_and_display "取消删除路径。" "${BLUE}"
                    fi
                else
                    log_and_display "${RED}无效的路径序号。${NC}"
                fi
                press_enter_to_continue
                ;;
            0)
                log_and_display "返回自定义备份路径菜单。" "${BLUE}"
                break
                ;;
            *)
                log_and_display "${RED}无效的选项，请重新输入。${NC}"
                press_enter_to_continue
                ;;
        esac
    done
}

# 3. 自定义备份路径主函数
set_backup_path() {
    while true; do
        display_header
        echo -e "${BLUE}=== 3. 自定义备份路径 ===${NC}"
        echo "当前已配置备份路径数量: ${#BACKUP_SOURCE_PATHS_ARRAY[@]} 个"
        echo ""
        echo "1. 添加新的备份路径"
        echo "2. 查看/修改/删除现有备份路径"
        echo "0. 返回主菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"
        read -rp "请输入选项: " choice

        case $choice in
            1) add_backup_path ;;
            2) view_and_manage_backup_paths ;;
            0)
                log_and_display "返回主菜单。" "${BLUE}"
                break
                ;;
            *)
                log_and_display "${RED}无效的选项，请重新输入。${NC}"
                press_enter_to_continue
                ;;
        esac
    done
}

# 4. 压缩格式信息 (保持不变)
display_compression_info() {
    display_header
    echo -e "${BLUE}=== 4. 压缩包格式 ===${NC}"
    log_and_display "本脚本当前支持的压缩格式为：${GREEN}ZIP${NC}。" ""
    log_and_display "如果您需要其他格式（如 .tar.gz），请修改脚本中 'perform_backup' 函数的压缩命令。" "${YELLOW}"
    press_enter_to_continue
}

# --- 云存储连接测试和文件夹列表 ---

# 测试 S3/R2 连接
test_s3_r2_connection() {
    if [[ -z "$S3_ACCESS_KEY" || -z "$S3_SECRET_KEY" || -z "$S3_ENDPOINT" || -z "$S3_BUCKET_NAME" ]]; then
        log_and_display "${RED}S3/R2 配置不完整，无法测试连接。请先填写 Access Key, Secret Key, Endpoint 和 Bucket 名称。${NC}" "" "/dev/stderr"
        return 1
    fi

    log_and_display "正在测试 S3/R2 连接到桶：${S3_BUCKET_NAME}..." "${BLUE}" "/dev/stderr"

    # 临时设置 AWS 环境变量以供 awscli 使用
    export AWS_ACCESS_KEY_ID="$S3_ACCESS_KEY"
    export AWS_SECRET_ACCESS_KEY="$S3_SECRET_KEY"

    local test_output=""
    local test_status=1

    if command -v aws &> /dev/null; then
        # 尝试列出桶内少量对象，带超时，用于测试连接
        test_output=$(aws s3 ls "s3://${S3_BUCKET_NAME}/" --endpoint-url "$S3_ENDPOINT" --page-size 1 --cli-read-timeout 10 --cli-connect-timeout 10 2>&1)
        test_status=$?
    elif command -v s3cmd &> /dev/null; then
        log_and_display "${YELLOW}正在使用 s3cmd 进行连接测试。请确保 ~/.s3cfg 已正确配置 Cloudflare R2。${NC}" "" "/dev/stderr"
        # s3cmd 通常会读取 ~/.s3cfg 或通过命令行参数，这里不强制传递凭证
        test_output=$(s3cmd ls "s3://${S3_BUCKET_NAME}/" 2>&1)
        test_status=$?
    else
        log_and_display "${RED}未找到 'awscli' 或 's3cmd' 命令，无法测试 S3/R2 连接。${NC}" "" "/dev/stderr"
        unset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY
        return 1
    fi

    # 清理 AWS 环境变量
    unset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY

    if [ "$test_status" -eq 0 ]; then
        log_and_display "${GREEN}S3/R2 连接成功！${NC}" "" "/dev/stderr"
        return 0
    else
        log_and_display "${RED}S3/R2 连接失败！请检查配置、凭证和网络连接。错误信息: ${test_output}${NC}" "" "/dev/stderr"
        return 1
    fi
}

# 获取 S3/R2 桶中的文件夹列表
get_s3_r2_folders() {
    # test_s3_r2_connection 的输出现在会到 stderr，不会影响这里的捕获
    if test_s3_r2_connection; then
        log_and_display "正在获取 S3/R2 存储桶中的文件夹列表 (最多显示50个)：" "${BLUE}" "/dev/stderr"
        export AWS_ACCESS_KEY_ID="$S3_ACCESS_KEY"
        export AWS_SECRET_ACCESS_KEY="$S3_SECRET_KEY"
        local folders=()

        # 捕获 aws 或 s3cmd 的标准输出，将标准错误重定向到 /dev/null
        if command -v aws &> /dev/null; then
            folders=($(aws s3 ls "s3://${S3_BUCKET_NAME}/" --endpoint-url "$S3_ENDPOINT" --delimiter '/' --query "CommonPrefixes[].Prefix" --output text 2>/dev/null))
        elif command -v s3cmd &> /dev/null; then
            log_and_display "${YELLOW}正在使用 s3cmd 尝试列出 S3/R2 文件夹。${NC}" "" "/dev/stderr"
            folders=($(s3cmd ls "s3://${S3_BUCKET_NAME}/" 2>/dev/null | grep -E '\/$' | awk '{print $NF}' | sed 's|s3://'"${S3_BUCKET_NAME//./\\.}"'\///' | head -n 50))
        fi
        unset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY

        if [ ${#folders[@]} -eq 0 ]; then
            log_and_display "${YELLOW}S3/R2 存储桶中没有检测到文件夹。${NC}" "" "/dev/stderr"
        else
            printf '%s\n' "${folders[@]}" # Only folder names go to stdout
            return 0
        fi
    else
        log_and_display "${RED}S3/R2 连接失败，无法获取文件夹列表。${NC}" "" "/dev/stderr"
        return 1
    fi
}

# 测试 WebDAV 连接
test_webdav_connection() {
    if [[ -z "$WEBDAV_URL" || -z "$WEBDAV_USERNAME" || -z "$WEBDAV_PASSWORD" ]]; then
        log_and_display "${RED}WebDAV 配置不完整，无法测试连接。请先填写 URL, 用户名和密码。${NC}" "" "/dev/stderr"
        return 1
    fi

    log_and_display "正在测试 WebDAV 连接到：${WEBDAV_URL}..." "${BLUE}" "/dev/stderr"

    # 使用 PROPFIND 方法测试连接，并检查 HTTP 状态码
    local http_code=$(curl -s -o /dev/null -w "%{http_code}" -L -k --user "$WEBDAV_USERNAME:$WEBDAV_PASSWORD" --request PROPFIND --header "Depth: 1" "${WEBDAV_URL%/}/" 2>/dev/null)
    local curl_status=$? # 获取 curl 的退出状态码

    if [ "$curl_status" -eq 0 ] && [[ "$http_code" -ge 200 && "$http_code" -lt 300 ]]; then
        log_and_display "${GREEN}WebDAV 连接成功！ (HTTP状态码: ${http_code})${NC}" "" "/dev/stderr"
        return 0
    else
        log_and_display "${RED}WebDAV 连接失败！HTTP状态码: ${http_code}。请检查配置、凭证和网络连接。${NC}" "" "/dev/stderr"
        log_and_display "${RED}Curl 错误码: ${curl_status}。${NC}" "" "/dev/stderr"
        return 1
    fi
}

# 获取 WebDAV 服务器中的文件夹列表
get_webdav_folders() {
    if test_webdav_connection; then
        log_and_display "正在获取 WebDAV 服务器中的文件夹列表 (最多显示50个)：" "${BLUE}" "/dev/stderr"
        local folders=()
        local curl_output=""

        # 使用 PROPFIND 获取目录列表，解析 XML 响应
        # 确保 WEBDAV_URL 以 / 结尾以便 PROPFIND 正确列出子项
        curl_output=$(curl -s -L -k --user "$WEBDAV_USERNAME:$WEBDAV_PASSWORD" --request PROPFIND --header "Depth: 1" "${WEBDAV_URL%/}/" 2>/dev/null)

        if [ $? -eq 0 ]; then
            # 从 XML 响应中提取 href 标签的内容
            # 筛选出以 '/' 结尾的目录，并去除 WebDAV URL 前缀以获得相对路径
            local base_url_escaped=$(echo "${WEBDAV_URL%/}/" | sed 's|/|\\/|g; s|\.|\\.|g')
            # 优化正则，更准确地匹配目录，并去除最后的斜杠方便显示
            folders=($(echo "$curl_output" | grep -oP '<D:href>\K([^<]*?\/)(?=</D:href>)' | sed 's|^\(http\|https\):\/\/[^/]*||' | grep -E '\/$' | grep -v "$base_url_escaped" | sed 's|/$||' | head -n 50))
        fi

        if [ ${#folders[@]} -eq 0 ]; then
            log_and_display "${YELLOW}WebDAV 服务器中没有检测到文件夹。${NC}" "" "/dev/stderr"
        else
            printf '%s\n' "${folders[@]}" # Only folder names go to stdout
            return 0
        fi
    else
        log_and_display "${RED}WebDAV 连接失败，无法获取文件夹列表。${NC}" "" "/dev/stderr"
        return 1
    fi
}

# --- 新增 FTP/FTPS/SFTP 连接测试和文件夹列表函数 ---

# 测试 FTP 连接
test_ftp_connection() {
    if [[ -z "$FTP_HOST" || -z "$FTP_USERNAME" || -z "$FTP_PASSWORD" ]]; then
        log_and_display "${RED}FTP 配置不完整，无法测试连接。请先填写主机、用户名和密码。${NC}" "" "/dev/stderr"
        return 1
    fi

    log_and_display "正在测试 FTP 连接到：${FTP_HOST}:${FTP_PORT}..." "${BLUE}" "/dev/stderr"

    # 使用 lftp 进行连接测试，ls 命令成功则认为连接成功
    if lftp -u "$FTP_USERNAME","$FTP_PASSWORD" -p "$FTP_PORT" "$FTP_HOST" -e 'ls /; quit;' &> /dev/null; then
        log_and_display "${GREEN}FTP 连接成功！${NC}" "" "/dev/stderr"
        return 0
    else
        log_and_display "${RED}FTP 连接失败！请检查配置、凭证、端口和网络连接。${NC}" "" "/dev/stderr"
        return 1
    fi
}

# 获取 FTP 服务器中的文件夹列表
get_ftp_folders() {
    if test_ftp_connection; then
        log_and_display "正在获取 FTP 服务器中的文件夹列表 (最多显示50个)：" "${BLUE}" "/dev/stderr"
        local folders=()
        # 使用 lftp ls 命令列出目录，并过滤出目录（以 / 结尾）
        # `ls -d */` 只列出目录
        local lftp_output=$(lftp -u "$FTP_USERNAME","$FTP_PASSWORD" -p "$FTP_PORT" "$FTP_HOST" -e 'ls -d */; quit;' 2>/dev/null)
        if [ $? -eq 0 ]; then
            # 清理 lftp 的输出，只保留文件夹名并去除末尾的斜杠
            folders=($(echo "$lftp_output" | sed 's|/$||' | head -n 50))
        fi

        if [ ${#folders[@]} -eq 0 ]; then
            log_and_display "${YELLOW}FTP 服务器中没有检测到文件夹。${NC}" "" "/dev/stderr"
        else
            printf '%s\n' "${folders[@]}"
            return 0
        fi
    else
        log_and_display "${RED}FTP 连接失败，无法获取文件夹列表。${NC}" "" "/dev/stderr"
        return 1
    fi
}

# 测试 FTPS 连接
test_ftps_connection() {
    if [[ -z "$FTPS_HOST" || -z "$FTPS_USERNAME" || -z "$FTPS_PASSWORD" ]]; then
        log_and_display "${RED}FTPS 配置不完整，无法测试连接。请先填写主机、用户名和密码。${NC}" "" "/dev/stderr"
        return 1
    fi

    log_and_display "正在测试 FTPS 连接到：${FTPS_HOST}:${FTPS_PORT}..." "${BLUE}" "/dev/stderr"

    # 使用 lftp 的 ftps:// 协议进行连接测试
    if lftp -u "$FTPS_USERNAME","$FTPS_PASSWORD" -p "$FTPS_PORT" ftps://"$FTPS_HOST" -e 'ls /; quit;' &> /dev/null; then
        log_and_display "${GREEN}FTPS 连接成功！${NC}" "" "/dev/stderr"
        return 0
    else
        log_and_display "${RED}FTPS 连接失败！请检查配置、凭证、端口和网络连接。${NC}" "" "/dev/stderr"
        return 1
    fi
}

# 获取 FTPS 服务器中的文件夹列表
get_ftps_folders() {
    if test_ftps_connection; then
        log_and_display "正在获取 FTPS 服务器中的文件夹列表 (最多显示50个)：" "${BLUE}" "/dev/stderr"
        local folders=()
        local lftp_output=$(lftp -u "$FTPS_USERNAME","$FTPS_PASSWORD" -p "$FTPS_PORT" ftps://"$FTPS_HOST" -e 'ls -d */; quit;' 2>/dev/null)
        if [ $? -eq 0 ]; then
            folders=($(echo "$lftp_output" | sed 's|/$||' | head -n 50))
        fi

        if [ ${#folders[@]} -eq 0 ]; then
            log_and_display "${YELLOW}FTPS 服务器中没有检测到文件夹。${NC}" "" "/dev/stderr"
        else
            printf '%s\n' "${folders[@]}"
            return 0
        fi
    else
        log_and_display "${RED}FTPS 连接失败，无法获取文件夹列表。${NC}" "" "/dev/stderr"
        return 1
    fi
}

# 测试 SFTP 连接
test_sftp_connection() {
    if [[ -z "$SFTP_HOST" || -z "$SFTP_USERNAME" || -z "$SFTP_PASSWORD" ]]; then
        log_and_display "${RED}SFTP 配置不完整，无法测试连接。请先填写主机、用户名和密码。${NC}" "" "/dev/stderr"
        return 1
    fi

    log_and_display "正在测试 SFTP 连接到：${SFTP_USERNAME}@${SFTP_HOST}:${SFTP_PORT}..." "${BLUE}" "/dev/stderr"
    log_and_display "${YELLOW}注意：SFTP 密码认证依赖于 'sshpass'。如果遇到问题，建议使用 SSH 密钥。${NC}" "" "/dev/stderr"

    # 使用 sshpass 结合 sftp 进行连接测试
    if command -v sshpass &> /dev/null; then
        if sshpass -p "$SFTP_PASSWORD" sftp -oBatchMode=no -b - -P "$SFTP_PORT" "$SFTP_USERNAME@$SFTP_HOST" <<< "ls /; quit;" &> /dev/null; then
            log_and_display "${GREEN}SFTP 连接成功！${NC}" "" "/dev/stderr"
            return 0
        else
            log_and_display "${RED}SFTP 连接失败！请检查配置、凭证、端口和网络连接。${NC}" "" "/dev/stderr"
            return 1
        fi
    else
        log_and_display "${RED}错误：未找到 'sshpass' 命令。SFTP 密码认证需要安装 'sshpass'。${NC}" "" "/dev/stderr"
        log_and_display "${RED}请安装 'sshpass' 或配置 SSH 密钥以进行无密码登录。${NC}" "" "/dev/stderr"
        return 1
    fi
}

# 获取 SFTP 服务器中的文件夹列表
get_sftp_folders() {
    if test_sftp_connection; then # 确保 sshpass 存在且连接成功
        log_and_display "正在获取 SFTP 服务器中的文件夹列表 (最多显示50个)：" "${BLUE}" "/dev/stderr"
        local folders=()
        local sftp_output=""
        # 使用 sshpass 结合 sftp 的 ls 命令列出目录
        # `ls -l` 可以显示类型，然后通过 grep 过滤
        sftp_output=$(sshpass -p "$SFTP_PASSWORD" sftp -oBatchMode=no -b - -P "$SFTP_PORT" "$SFTP_USERNAME@$SFTP_HOST" <<< "ls -F /; quit;" 2>/dev/null)

        if [ $? -eq 0 ]; then
            # 过滤出以 '/' 结尾的行（表示目录），并去除末尾的斜杠
            folders=($(echo "$sftp_output" | grep -E '/$' | sed 's|/$||' | head -n 50))
        fi

        if [ ${#folders[@]} -eq 0 ]; then
            log_and_display "${YELLOW}SFTP 服务器中没有检测到文件夹。${NC}" "" "/dev/stderr"
        else
            printf '%s\n' "${folders[@]}"
            return 0
        fi
    else
        log_and_display "${RED}SFTP 连接失败，无法获取文件夹列表。${NC}" "" "/dev/stderr"
        return 1
    fi
}

# ================================================================
# ===           新增 FTP/FTPS/SFTP 路径选择函数               ===
# ================================================================

choose_s3_r2_path() {
    local selected_path=""

    while true; do
        display_header
        echo -e "${BLUE}=== 设置 S3/R2 备份目标路径 ===${NC}"
        echo -e "当前路径: ${YELLOW}${S3_BACKUP_PATH:-/ (根目录)}${NC}\n"

        local s3_folders_str=$(get_s3_r2_folders)
        local s3_folders_array=()
        if [[ -n "$s3_folders_str" ]]; then
            mapfile -t s3_folders_array <<< "$s3_folders_str"
        fi

        if [ ${#s3_folders_array[@]} -gt 0 ]; then
            echo "云端可用文件夹:"
            for i in "${!s3_folders_array[@]}"; do
                echo "  $((i+1)). ${s3_folders_array[$i]}"
            done
            echo ""
            echo "请输入数字以选择一个现有文件夹。"
        else
            echo "云端未找到任何文件夹。"
        fi

        echo -e "${BLUE}------------------------------------------------${NC}"
        echo "操作选项:"
        echo -e "  ${GREEN}a${NC} - 手动输入一个新的文件夹路径 (例如 my_new_folder/)"
        echo -e "  ${GREEN}r${NC} - 设置备份路径为存储桶的根目录"
        echo -e "  ${GREEN}c${NC} - 取消并返回上一级菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"

        read -rp "请输入您的选择 (数字或字母): " choice

        if [[ "$choice" =~ ^[0-9]+$ ]]; then
            if [ "$choice" -ge 1 ] && [ "$choice" -le ${#s3_folders_array[@]} ]; then
                selected_path="${s3_folders_array[$((choice-1))]}"
                break
            else
                log_and_display "${RED}无效的数字序号，请重新输入。${NC}"
                press_enter_to_continue
                continue
            fi
        elif [[ "$choice" =~ ^[aArRcC]$ ]]; then
            case "${choice,,}" in
                a)
                    read -rp "请输入新的 S3/R2 目标路径 (例如 my_backups/daily/): " new_path
                    selected_path="$new_path"
                    break
                    ;;
                r)
                    selected_path=""
                    break
                    ;;
                c)
                    log_and_display "取消设置 S3/R2 备份路径。" "${BLUE}"
                    return 1
                    ;;
            esac
        else
            log_and_display "${RED}无效的输入，请输入列表中的数字或指定的字母选项。${NC}"
            press_enter_to_continue
        fi
    done

    if [[ -n "$selected_path" && "${selected_path: -1}" != "/" ]]; then
        selected_path="${selected_path}/"
    fi

    local display_path_confirm="${selected_path:-/ (根目录)}"
    read -rp "您选择的 S3/R2 目标路径是 '${display_path_confirm}'。确认吗？(y/N): " confirm_path
    if [[ "$confirm_path" =~ ^[Yy]$ ]]; then
        S3_BACKUP_PATH="$selected_path"
        log_and_display "${GREEN}S3/R2 备份路径已设置为：${display_path_confirm}${NC}"
        return 0
    else
        log_and_display "${YELLOW}取消设置，请重新选择。${NC}"
        return 1
    fi
}

choose_webdav_path() {
    local selected_path=""

    while true; do
        display_header
        echo -e "${BLUE}=== 设置 WebDAV 备份目标路径 ===${NC}"
        echo -e "当前路径: ${YELLOW}${WEBDAV_BACKUP_PATH:-/ (根目录)}${NC}\n"

        local webdav_folders_str=$(get_webdav_folders)
        local webdav_folders_array=()
        if [[ -n "$webdav_folders_str" ]]; then
            mapfile -t webdav_folders_array <<< "$webdav_folders_str"
        fi

        if [ ${#webdav_folders_array[@]} -gt 0 ]; then
            echo "云端可用文件夹:"
            for i in "${!webdav_folders_array[@]}"; do
                echo "  $((i+1)). ${webdav_folders_array[$i]}"
            done
            echo ""
            echo "请输入数字以选择一个现有文件夹。"
        else
            echo "云端未找到任何文件夹。"
        fi

        echo -e "${BLUE}------------------------------------------------${NC}"
        echo "操作选项:"
        echo -e "  ${GREEN}a${NC} - 手动输入一个新的文件夹路径 (例如 my_new_folder/)"
        echo -e "  ${GREEN}r${NC} - 设置备份路径为 WebDAV 的根目录"
        echo -e "  ${GREEN}c${NC} - 取消并返回上一级菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"

        read -rp "请输入您的选择 (数字或字母): " choice

        if [[ "$choice" =~ ^[0-9]+$ ]]; then
            if [ "$choice" -ge 1 ] && [ "$choice" -le ${#webdav_folders_array[@]} ]; then
                selected_path="${webdav_folders_array[$((choice-1))]}"
                break
            else
                log_and_display "${RED}无效的数字序号，请重新输入。${NC}"
                press_enter_to_continue
                continue
            fi
        elif [[ "$choice" =~ ^[aArRcC]$ ]]; then
            case "${choice,,}" in
                a)
                    read -rp "请输入新的 WebDAV 目标路径 (例如 my_backups/daily/): " new_path
                    selected_path="$new_path"
                    break
                    ;;
                r)
                    selected_path=""
                    break
                    ;;
                c)
                    log_and_display "取消设置 WebDAV 备份路径。" "${BLUE}"
                    return 1
                    ;;
            esac
        else
            log_and_display "${RED}无效的输入，请输入列表中的数字或指定的字母选项。${NC}"
            press_enter_to_continue
        fi
    done

    if [[ -n "$selected_path" && "${selected_path: -1}" != "/" ]]; then
        selected_path="${selected_path}/"
    fi

    local display_path_confirm="${selected_path:-/ (根目录)}"
    read -rp "您选择的 WebDAV 目标路径是 '${display_path_confirm}'。确认吗？(y/N): " confirm_path
    if [[ "$confirm_path" =~ ^[Yy]$ ]]; then
        WEBDAV_BACKUP_PATH="$selected_path"
        log_and_display "${GREEN}WebDAV 备份路径已设置为：${display_path_confirm}${NC}"
        return 0
    else
        log_and_display "${YELLOW}取消设置，请重新选择。${NC}"
        return 1
    fi
}

choose_ftp_path() {
    local selected_path=""

    while true; do
        display_header
        echo -e "${BLUE}=== 设置 FTP 备份目标路径 ===${NC}"
        echo -e "当前路径: ${YELLOW}${FTP_BACKUP_PATH:-/ (根目录)}${NC}\n"

        local ftp_folders_str=$(get_ftp_folders)
        local ftp_folders_array=()
        if [[ -n "$ftp_folders_str" ]]; then
            mapfile -t ftp_folders_array <<< "$ftp_folders_str"
        fi

        if [ ${#ftp_folders_array[@]} -gt 0 ]; then
            echo "FTP 服务器上可用文件夹:"
            for i in "${!ftp_folders_array[@]}"; do
                echo "  $((i+1)). ${ftp_folders_array[$i]}"
            done
            echo ""
            echo "请输入数字以选择一个现有文件夹。"
        else
            echo "FTP 服务器上未找到任何文件夹。"
        fi

        echo -e "${BLUE}------------------------------------------------${NC}"
        echo "操作选项:"
        echo -e "  ${GREEN}a${NC} - 手动输入一个新的文件夹路径 (例如 my_new_folder/)"
        echo -e "  ${GREEN}r${NC} - 设置备份路径为 FTP 的根目录"
        echo -e "  ${GREEN}c${NC} - 取消并返回上一级菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"

        read -rp "请输入您的选择 (数字或字母): " choice

        if [[ "$choice" =~ ^[0-9]+$ ]]; then
            if [ "$choice" -ge 1 ] && [ "$choice" -le ${#ftp_folders_array[@]} ]; then
                selected_path="${ftp_folders_array[$((choice-1))]}"
                break
            else
                log_and_display "${RED}无效的数字序号，请重新输入。${NC}"
                press_enter_to_continue
                continue
            fi
        elif [[ "$choice" =~ ^[aArRcC]$ ]]; then
            case "${choice,,}" in
                a)
                    read -rp "请输入新的 FTP 目标路径 (例如 my_backups/daily/): " new_path
                    selected_path="$new_path"
                    break
                    ;;
                r)
                    selected_path="/" # FTP 根目录通常为 /
                    break
                    ;;
                c)
                    log_and_display "取消设置 FTP 备份路径。" "${BLUE}"
                    return 1
                    ;;
            esac
        else
            log_and_display "${RED}无效的输入，请输入列表中的数字或指定的字母选项。${NC}"
            press_enter_to_continue
        fi
    done

    # 确保路径以斜杠结尾，除非是根目录 "/"
    if [[ -n "$selected_path" && "$selected_path" != "/" && "${selected_path: -1}" != "/" ]]; then
        selected_path="${selected_path}/"
    fi

    local display_path_confirm="${selected_path:-/ (根目录)}"
    read -rp "您选择的 FTP 目标路径是 '${display_path_confirm}'。确认吗？(y/N): " confirm_path
    if [[ "$confirm_path" =~ ^[Yy]$ ]]; then
        FTP_BACKUP_PATH="$selected_path"
        log_and_display "${GREEN}FTP 备份路径已设置为：${display_path_confirm}${NC}"
        return 0
    else
        log_and_display "${YELLOW}取消设置，请重新选择。${NC}"
        return 1
    fi
}

choose_ftps_path() {
    local selected_path=""

    while true; do
        display_header
        echo -e "${BLUE}=== 设置 FTPS 备份目标路径 ===${NC}"
        echo -e "当前路径: ${YELLOW}${FTPS_BACKUP_PATH:-/ (根目录)}${NC}\n"

        local ftps_folders_str=$(get_ftps_folders)
        local ftps_folders_array=()
        if [[ -n "$ftps_folders_str" ]]; then
            mapfile -t ftps_folders_array <<< "$ftps_folders_str"
        fi

        if [ ${#ftps_folders_array[@]} -gt 0 ]; then
            echo "FTPS 服务器上可用文件夹:"
            for i in "${!ftps_folders_array[@]}"; do
                echo "  $((i+1)). ${ftps_folders_array[$i]}"
            done
            echo ""
            echo "请输入数字以选择一个现有文件夹。"
        else
            echo "FTPS 服务器上未找到任何文件夹。"
        fi

        echo -e "${BLUE}------------------------------------------------${NC}"
        echo "操作选项:"
        echo -e "  ${GREEN}a${NC} - 手动输入一个新的文件夹路径 (例如 my_new_folder/)"
        echo -e "  ${GREEN}r${NC} - 设置备份路径为 FTPS 的根目录"
        echo -e "  ${GREEN}c${NC} - 取消并返回上一级菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"

        read -rp "请输入您的选择 (数字或字母): " choice

        if [[ "$choice" =~ ^[0-9]+$ ]]; then
            if [ "$choice" -ge 1 ] && [ "$choice" -le ${#ftps_folders_array[@]} ]; then
                selected_path="${ftps_folders_array[$((choice-1))]}"
                break
            else
                log_and_display "${RED}无效的数字序号，请重新输入。${NC}"
                press_enter_to_continue
                continue
            fi
        elif [[ "$choice" =~ ^[aArRcC]$ ]]; then
            case "${choice,,}" in
                a)
                    read -rp "请输入新的 FTPS 目标路径 (例如 my_backups/daily/): " new_path
                    selected_path="$new_path"
                    break
                    ;;
                r)
                    selected_path="/"
                    break
                    ;;
                c)
                    log_and_display "取消设置 FTPS 备份路径。" "${BLUE}"
                    return 1
                    ;;
            esac
        else
            log_and_display "${RED}无效的输入，请输入列表中的数字或指定的字母选项。${NC}"
            press_enter_to_continue
        fi
    done

    if [[ -n "$selected_path" && "$selected_path" != "/" && "${selected_path: -1}" != "/" ]]; then
        selected_path="${selected_path}/"
    fi

    local display_path_confirm="${selected_path:-/ (根目录)}"
    read -rp "您选择的 FTPS 目标路径是 '${display_path_confirm}'。确认吗？(y/N): " confirm_path
    if [[ "$confirm_path" =~ ^[Yy]$ ]]; then
        FTPS_BACKUP_PATH="$selected_path"
        log_and_display "${GREEN}FTPS 备份路径已设置为：${display_path_confirm}${NC}"
        return 0
    else
        log_and_display "${YELLOW}取消设置，请重新选择。${NC}"
        return 1
    fi
}

choose_sftp_path() {
    local selected_path=""

    while true; do
        display_header
        echo -e "${BLUE}=== 设置 SFTP 备份目标路径 ===${NC}"
        echo -e "当前路径: ${YELLOW}${SFTP_BACKUP_PATH:-/ (根目录)}${NC}\n"

        local sftp_folders_str=$(get_sftp_folders)
        local sftp_folders_array=()
        if [[ -n "$sftp_folders_str" ]]; then
            mapfile -t sftp_folders_array <<< "$sftp_folders_str"
        fi

        if [ ${#sftp_folders_array[@]} -gt 0 ]; then
            echo "SFTP 服务器上可用文件夹:"
            for i in "${!sftp_folders_array[@]}"; do
                echo "  $((i+1)). ${sftp_folders_array[$i]}"
            done
            echo ""
            echo "请输入数字以选择一个现有文件夹。"
        else
            echo "SFTP 服务器上未找到任何文件夹。"
        fi

        echo -e "${BLUE}------------------------------------------------${NC}"
        echo "操作选项:"
        echo -e "  ${GREEN}a${NC} - 手动输入一个新的文件夹路径 (例如 my_new_folder/)"
        echo -e "  ${GREEN}r${NC} - 设置备份路径为 SFTP 的根目录"
        echo -e "  ${GREEN}c${NC} - 取消并返回上一级菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"

        read -rp "请输入您的选择 (数字或字母): " choice

        if [[ "$choice" =~ ^[0-9]+$ ]]; then
            if [ "$choice" -ge 1 ] && [ "$choice" -le ${#sftp_folders_array[@]} ]; then
                selected_path="${sftp_folders_array[$((choice-1))]}"
                break
            else
                log_and_display "${RED}无效的数字序号，请重新输入。${NC}"
                press_enter_to_continue
                continue
            fi
        elif [[ "$choice" =~ ^[aArRcC]$ ]]; then
            case "${choice,,}" in
                a)
                    read -rp "请输入新的 SFTP 目标路径 (例如 my_backups/daily/): " new_path
                    selected_path="$new_path"
                    break
                    ;;
                r)
                    selected_path="/"
                    break
                    ;;
                c)
                    log_and_display "取消设置 SFTP 备份路径。" "${BLUE}"
                    return 1
                    ;;
            esac
        else
            log_and_display "${RED}无效的输入，请输入列表中的数字或指定的字母选项。${NC}"
            press_enter_to_continue
        fi
    done

    if [[ -n "$selected_path" && "$selected_path" != "/" && "${selected_path: -1}" != "/" ]]; then
        selected_path="${selected_path}/"
    fi

    local display_path_confirm="${selected_path:-/ (根目录)}"
    read -rp "您选择的 SFTP 目标路径是 '${display_path_confirm}'。确认吗？(y/N): " confirm_path
    if [[ "$confirm_path" =~ ^[Yy]$ ]]; then
        SFTP_BACKUP_PATH="$selected_path"
        log_and_display "${GREEN}SFTP 备份路径已设置为：${display_path_confirm}${NC}"
        return 0
    else
        log_and_display "${YELLOW}取消设置，请重新选择。${NC}"
        return 1
    fi
}


# ================================================================
# ===           新增 FTP/FTPS/SFTP 账号管理菜单               ===
# ================================================================

# 管理 S3/R2 账号设置
manage_s3_r2_account() {
    while true; do
        display_header
        echo -e "${BLUE}=== 管理 S3/R2 存储账号 ===${NC}"
        local s3_status="${RED}未配置${NC}"
        local s3_path_status="${YELLOW}未设置目标路径${NC}"

        # 判断 S3/R2 账号是否已配置
        if [[ -n "$S3_ACCESS_KEY" && -n "$S3_SECRET_KEY" && -n "$S3_ENDPOINT" && -n "$S3_BUCKET_NAME" ]]; then
            s3_status="${GREEN}已配置${NC} (桶: ${S3_BUCKET_NAME})"
            if [[ -n "$S3_BACKUP_PATH" ]]; then
                s3_path_status="${GREEN}已设置目标路径: ${S3_BACKUP_PATH}${NC}"
            fi
        fi

        echo "当前 S3/R2 账号状态: $s3_status"
        echo "S3/R2 目标路径状态: $s3_path_status"
        echo ""
        echo "1. 添加/修改 S3/R2 账号凭证"
        echo "2. 测试 S3/R2 连接"
        echo "3. 设置备份目标路径"
        echo "4. 清除 S3/R2 账号配置"
        echo "0. 返回云存储设定主菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"
        read -rp "请输入选项: " sub_choice

        case $sub_choice in
            1)
                log_and_display "--- 添加/修改 S3/R2 账号凭证 ---"
                log_and_display "${YELLOW}凭证将保存到本地配置文件，请确保配置文件安全！${NC}"
                # Changed: Do not display current Access Key directly
                read -rp "请输入 S3/R2 Access Key ID [当前: $(if [[ -n "$S3_ACCESS_KEY" ]]; then echo "已设置"; else echo "未设置"; fi)]: " input_key
                S3_ACCESS_KEY="${input_key:-$S3_ACCESS_KEY}" # 如果输入为空，保留当前值

                # Changed: Use -s for secret key and hide current value
                read -s -rp "请输入 S3/R2 Secret Access Key (留空不修改当前密钥): " input_secret
                echo "" # Newline after hidden input
                if [[ -n "$input_secret" ]]; then # Only update if new secret is provided
                    S3_SECRET_KEY="$input_secret"
                fi

                read -rp "请输入 S3/R2 Endpoint URL (例如 Cloudflare R2 的 https://<ACCOUNT_ID>.r2.cloudflarestorage.com) [当前: ${S3_ENDPOINT}]: " input_endpoint
                S3_ENDPOINT="${input_endpoint:-$S3_ENDPOINT}"

                read -rp "请输入 S3/R2 Bucket 名称 [当前: ${S3_BUCKET_NAME}]: " input_bucket
                S3_BUCKET_NAME="${input_bucket:-$S3_BUCKET_NAME}"

                save_config
                log_and_display "${GREEN}S3/R2 账号凭证已更新并保存。${NC}"
                press_enter_to_continue
                ;;
            2)
                test_s3_r2_connection
                press_enter_to_continue
                ;;
            3)
                # 检查凭证是否已设置
                if [[ -z "$S3_ACCESS_KEY" || -z "$S3_SECRET_KEY" || -z "$S3_ENDPOINT" || -z "$S3_BUCKET_NAME" ]]; then
                    log_and_display "${RED}S3/R2 配置不完整，无法设置目标路径。请先通过选项 '1' 添加凭证。${NC}"
                else
                    if choose_s3_r2_path; then
                        save_config # 仅在路径成功设置后保存
                    fi
                fi
                press_enter_to_continue
                ;;
            4)
                log_and_display "${YELLOW}警告：这将清除所有 S3/R2 账号配置。确定吗？(y/N)${NC}"
                read -rp "请确认: " confirm_clear
                if [[ "$confirm_clear" =~ ^[Yy]$ ]]; then
                    S3_ACCESS_KEY=""
                    S3_SECRET_KEY=""
                    S3_ENDPOINT=""
                    S3_BUCKET_NAME=""
                    S3_BACKUP_PATH=""
                    BACKUP_TARGET_S3="false" # 禁用 S3 备份
                    save_config
                    log_and_display "${GREEN}S3/R2 账号配置已清除。${NC}"
                else
                    log_and_display "取消清除 S3/R2 账号配置。" "${BLUE}"
                fi
                press_enter_to_continue
                ;;
            0)
                log_and_display "返回云存储设定主菜单。" "${BLUE}"
                break
                ;;
            *)
                log_and_display "${RED}无效的选项，请重新输入。${NC}"
                press_enter_to_continue
                ;;
        esac
    done
}

# 管理 WebDAV 账号设置
manage_webdav_account() {
    while true; do
        display_header
        echo -e "${BLUE}=== 管理 WebDAV 存储账号 ===${NC}"
        local webdav_status="${RED}未配置${NC}"
        local webdav_path_status="${YELLOW}未设置目标路径${NC}"

        # 判断 WebDAV 账号是否已配置
        if [[ -n "$WEBDAV_URL" && -n "$WEBDAV_USERNAME" && -n "$WEBDAV_PASSWORD" ]]; then
            # 隐藏密码显示
            local display_url="${WEBDAV_URL}"
            display_url="${display_url/:\/\/www./:\/\/\*\*\*./}" # 简单替换，避免直接显示敏感部分
            webdav_status="${GREEN}已配置${NC} (URL: ${display_url} 用户名: ${WEBDAV_USERNAME})"
            if [[ -n "$WEBDAV_BACKUP_PATH" ]]; then
                webdav_path_status="${GREEN}已设置目标路径: ${WEBDAV_BACKUP_PATH}${NC}"
            fi
        fi

        echo "当前 WebDAV 账号状态: $webdav_status"
        echo "WebDAV 目标路径状态: $webdav_path_status"
        echo ""
        echo "1. 添加/修改 WebDAV 账号凭证"
        echo "2. 测试 WebDAV 连接"
        echo "3. 设置备份目标路径"
        echo "4. 清除 WebDAV 账号配置"
        echo "0. 返回云存储设定主菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"
        read -rp "请输入选项: " sub_choice

        case $sub_choice in
            1)
                log_and_display "--- 添加/修改 WebDAV 账号凭证 ---"
                log_and_display "${YELLOW}凭证将保存到本地配置文件，请确保配置文件安全！${NC}"
                read -rp "请输入 WebDAV URL (例如 http://your.webdav.server/path/) [当前: ${WEBDAV_URL}]: " input_url
                WEBDAV_URL="${input_url:-$WEBDAV_URL}"

                read -rp "请输入 WebDAV 用户名 [当前: ${WEBDAV_USERNAME}]: " input_username
                WEBDAV_USERNAME="${input_username:-$WEBDAV_USERNAME}"

                read -s -rp "请输入 WebDAV 密码 (留空不修改当前密码): " input_password
                echo "" # 隐藏输入后换行
                if [[ -n "$input_password" ]]; then # 仅在提供了新密码时才更新
                    WEBDAV_PASSWORD="$input_password"
                fi

                save_config
                log_and_display "${GREEN}WebDAV 账号凭证已更新并保存。${NC}"
                press_enter_to_continue
                ;;
            2)
                test_webdav_connection
                press_enter_to_continue
                ;;
            3)
                if [[ -z "$WEBDAV_URL" || -z "$WEBDAV_USERNAME" || -z "$WEBDAV_PASSWORD" ]]; then
                    log_and_display "${RED}WebDAV 配置不完整，无法设置目标路径。请先通过选项 '1' 添加凭证。${NC}"
                else
                    if choose_webdav_path; then
                        save_config # 仅在路径成功设置后保存
                    fi
                fi
                press_enter_to_continue
                ;;
            4)
                log_and_display "${YELLOW}警告：这将清除所有 WebDAV 账号配置。确定吗？(y/N)${NC}"
                read -rp "请确认: " confirm_clear
                if [[ "$confirm_clear" =~ ^[Yy]$ ]]; then
                    WEBDAV_URL=""
                    WEBDAV_USERNAME=""
                    WEBDAV_PASSWORD=""
                    WEBDAV_BACKUP_PATH=""
                    BACKUP_TARGET_WEBDAV="false" # 禁用 WebDAV 备份
                    save_config
                    log_and_display "${GREEN}WebDAV 账号配置已清除。${NC}"
                else
                    log_and_display "取消清除 WebDAV 账号配置。" "${BLUE}"
                fi
                press_enter_to_continue
                ;;
            0)
                log_and_display "返回云存储设定主菜单。" "${BLUE}"
                break
                ;;
            *)
                log_and_display "${RED}无效的选项，请重新输入。${NC}"
                press_enter_to_continue
                ;;
        esac
    done
}

# 管理 FTP 账号设置
manage_ftp_account() {
    while true; do
        display_header
        echo -e "${BLUE}=== 管理 FTP 存储账号 ===${NC}"
        local ftp_status="${RED}未配置${NC}"
        local ftp_path_status="${YELLOW}未设置目标路径${NC}"

        if [[ -n "$FTP_HOST" && -n "$FTP_USERNAME" && -n "$FTP_PASSWORD" ]]; then
            ftp_status="${GREEN}已配置${NC} (主机: ${FTP_HOST}:${FTP_PORT} 用户名: ${FTP_USERNAME})"
            if [[ -n "$FTP_BACKUP_PATH" ]]; then
                ftp_path_status="${GREEN}已设置目标路径: ${FTP_BACKUP_PATH}${NC}"
            fi
        fi

        echo "当前 FTP 账号状态: $ftp_status"
        echo "FTP 目标路径状态: $ftp_path_status"
        echo ""
        echo "1. 添加/修改 FTP 账号凭证"
        echo "2. 测试 FTP 连接"
        echo "3. 设置备份目标路径"
        echo "4. 清除 FTP 账号配置"
        echo "0. 返回云存储设定主菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"
        read -rp "请输入选项: " sub_choice

        case $sub_choice in
            1)
                log_and_display "--- 添加/修改 FTP 账号凭证 ---"
                log_and_display "${YELLOW}凭证将保存到本地配置文件，请确保配置文件安全！${NC}"
                read -rp "请输入 FTP 主机名 (例如 ftp.example.com) [当前: ${FTP_HOST}]: " input_host
                FTP_HOST="${input_host:-$FTP_HOST}"

                read -rp "请输入 FTP 用户名 [当前: ${FTP_USERNAME}]: " input_username
                FTP_USERNAME="${input_username:-$FTP_USERNAME}"

                read -s -rp "请输入 FTP 密码 (留空不修改当前密码): " input_password
                echo ""
                if [[ -n "$input_password" ]]; then
                    FTP_PASSWORD="$input_password"
                fi

                read -rp "请输入 FTP 端口 (默认: 21) [当前: ${FTP_PORT}]: " input_port
                FTP_PORT="${input_port:-$FTP_PORT}"
                [[ "$FTP_PORT" =~ ^[0-9]+$ ]] || FTP_PORT=21 # 确保是数字，否则恢复默认

                save_config
                log_and_display "${GREEN}FTP 账号凭证已更新并保存。${NC}"
                press_enter_to_continue
                ;;
            2)
                test_ftp_connection
                press_enter_to_continue
                ;;
            3)
                if [[ -z "$FTP_HOST" || -z "$FTP_USERNAME" || -z "$FTP_PASSWORD" ]]; then
                    log_and_display "${RED}FTP 配置不完整，无法设置目标路径。请先通过选项 '1' 添加凭证。${NC}"
                else
                    if choose_ftp_path; then
                        save_config
                    fi
                fi
                press_enter_to_continue
                ;;
            4)
                log_and_display "${YELLOW}警告：这将清除所有 FTP 账号配置。确定吗？(y/N)${NC}"
                read -rp "请确认: " confirm_clear
                if [[ "$confirm_clear" =~ ^[Yy]$ ]]; then
                    FTP_HOST=""
                    FTP_USERNAME=""
                    FTP_PASSWORD=""
                    FTP_PORT=21
                    FTP_BACKUP_PATH=""
                    BACKUP_TARGET_FTP="false"
                    save_config
                    log_and_display "${GREEN}FTP 账号配置已清除。${NC}"
                else
                    log_and_display "取消清除 FTP 账号配置。" "${BLUE}"
                fi
                press_enter_to_continue
                ;;
            0)
                log_and_display "返回云存储设定主菜单。" "${BLUE}"
                break
                ;;
            *)
                log_and_display "${RED}无效的选项，请重新输入。${NC}"
                press_enter_to_continue
                ;;
        esac
    done
}

# 管理 FTPS 账号设置
manage_ftps_account() {
    while true; do
        display_header
        echo -e "${BLUE}=== 管理 FTPS 存储账号 ===${NC}"
        local ftps_status="${RED}未配置${NC}"
        local ftps_path_status="${YELLOW}未设置目标路径${NC}"

        if [[ -n "$FTPS_HOST" && -n "$FTPS_USERNAME" && -n "$FTPS_PASSWORD" ]]; then
            ftps_status="${GREEN}已配置${NC} (主机: ${FTPS_HOST}:${FTPS_PORT} 用户名: ${FTPS_USERNAME})"
            if [[ -n "$FTPS_BACKUP_PATH" ]]; then
                ftps_path_status="${GREEN}已设置目标路径: ${FTPS_BACKUP_PATH}${NC}"
            fi
        fi

        echo "当前 FTPS 账号状态: $ftps_status"
        echo "FTPS 目标路径状态: $ftps_path_status"
        echo ""
        echo "1. 添加/修改 FTPS 账号凭证"
        echo "2. 测试 FTPS 连接"
        echo "3. 设置备份目标路径"
        echo "4. 清除 FTPS 账号配置"
        echo "0. 返回云存储设定主菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"
        read -rp "请输入选项: " sub_choice

        case $sub_choice in
            1)
                log_and_display "--- 添加/修改 FTPS 账号凭证 ---"
                log_and_display "${YELLOW}凭证将保存到本地配置文件，请确保配置文件安全！${NC}"
                read -rp "请输入 FTPS 主机名 (例如 ftps.example.com) [当前: ${FTPS_HOST}]: " input_host
                FTPS_HOST="${input_host:-$FTPS_HOST}"

                read -rp "请输入 FTPS 用户名 [当前: ${FTPS_USERNAME}]: " input_username
                FTPS_USERNAME="${input_username:-$FTPS_USERNAME}"

                read -s -rp "请输入 FTPS 密码 (留空不修改当前密码): " input_password
                echo ""
                if [[ -n "$input_password" ]]; then
                    FTPS_PASSWORD="$input_password"
                fi

                read -rp "请输入 FTPS 端口 (默认: 21) [当前: ${FTPS_PORT}]: " input_port
                FTPS_PORT="${input_port:-$FTPS_PORT}"
                [[ "$FTPS_PORT" =~ ^[0-9]+$ ]] || FTPS_PORT=21

                save_config
                log_and_display "${GREEN}FTPS 账号凭证已更新并保存。${NC}"
                press_enter_to_continue
                ;;
            2)
                test_ftps_connection
                press_enter_to_continue
                ;;
            3)
                if [[ -z "$FTPS_HOST" || -z "$FTPS_USERNAME" || -z "$FTPS_PASSWORD" ]]; then
                    log_and_display "${RED}FTPS 配置不完整，无法设置目标路径。请先通过选项 '1' 添加凭证。${NC}"
                else
                    if choose_ftps_path; then
                        save_config
                    fi
                fi
                press_enter_to_continue
                ;;
            4)
                log_and_display "${YELLOW}警告：这将清除所有 FTPS 账号配置。确定吗？(y/N)${NC}"
                read -rp "请确认: " confirm_clear
                if [[ "$confirm_clear" =~ ^[Yy]$ ]]; then
                    FTPS_HOST=""
                    FTPS_USERNAME=""
                    FTPS_PASSWORD=""
                    FTPS_PORT=21
                    FTPS_BACKUP_PATH=""
                    BACKUP_TARGET_FTPS="false"
                    save_config
                    log_and_display "${GREEN}FTPS 账号配置已清除。${NC}"
                else
                    log_and_display "取消清除 FTPS 账号配置。" "${BLUE}"
                fi
                press_enter_to_continue
                ;;
            0)
                log_and_display "返回云存储设定主菜单。" "${BLUE}"
                break
                ;;
            *)
                log_and_display "${RED}无效的选项，请重新输入。${NC}"
                press_enter_to_continue
                ;;
        esac
    done
}

# 管理 SFTP 账号设置
manage_sftp_account() {
    while true; do
        display_header
        echo -e "${BLUE}=== 管理 SFTP 存储账号 ===${NC}"
        local sftp_status="${RED}未配置${NC}"
        local sftp_path_status="${YELLOW}未设置目标路径${NC}"

        if [[ -n "$SFTP_HOST" && -n "$SFTP_USERNAME" && -n "$SFTP_PASSWORD" ]]; then
            sftp_status="${GREEN}已配置${NC} (主机: ${SFTP_HOST}:${SFTP_PORT} 用户名: ${SFTP_USERNAME})"
            if [[ -n "$SFTP_BACKUP_PATH" ]]; then
                sftp_path_status="${GREEN}已设置目标路径: ${SFTP_BACKUP_PATH}${NC}"
            fi
        fi

        echo "当前 SFTP 账号状态: $sftp_status"
        echo "SFTP 目标路径状态: $sftp_path_status"
        echo ""
        echo "1. 添加/修改 SFTP 账号凭证"
        echo "2. 测试 SFTP 连接"
        echo "3. 设置备份目标路径"
        echo "4. 清除 SFTP 账号配置"
        echo "0. 返回云存储设定主菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"
        read -rp "请输入选项: " sub_choice

        case $sub_choice in
            1)
                log_and_display "--- 添加/修改 SFTP 账号凭证 ---"
                log_and_display "${YELLOW}凭证将保存到本地配置文件，请确保配置文件安全！${NC}"
                log_and_display "${YELLOW}建议使用 SSH 密钥进行 SFTP 认证以提高安全性。${NC}"
                log_and_display "${YELLOW}如果使用密码，需要安装 'sshpass'。${NC}"
                read -rp "请输入 SFTP 主机名 (例如 sftp.example.com 或 192.168.1.1) [当前: ${SFTP_HOST}]: " input_host
                SFTP_HOST="${input_host:-$SFTP_HOST}"

                read -rp "请输入 SFTP 用户名 [当前: ${SFTP_USERNAME}]: " input_username
                SFTP_USERNAME="${input_username:-$SFTP_USERNAME}"

                read -s -rp "请输入 SFTP 密码 (留空不修改当前密码): " input_password
                echo ""
                if [[ -n "$input_password" ]]; then
                    SFTP_PASSWORD="$input_password"
                fi

                read -rp "请输入 SFTP 端口 (默认: 22) [当前: ${SFTP_PORT}]: " input_port
                SFTP_PORT="${input_port:-$SFTP_PORT}"
                [[ "$SFTP_PORT" =~ ^[0-9]+$ ]] || SFTP_PORT=22

                save_config
                log_and_display "${GREEN}SFTP 账号凭证已更新并保存。${NC}"
                press_enter_to_continue
                ;;
            2)
                test_sftp_connection
                press_enter_to_continue
                ;;
            3)
                if [[ -z "$SFTP_HOST" || -z "$SFTP_USERNAME" || -z "$SFTP_PASSWORD" ]]; then
                    log_and_display "${RED}SFTP 配置不完整，无法设置目标路径。请先通过选项 '1' 添加凭证。${NC}"
                else
                    if choose_sftp_path; then
                        save_config
                    fi
                fi
                press_enter_to_continue
                ;;
            4)
                log_and_display "${YELLOW}警告：这将清除所有 SFTP 账号配置。确定吗？(y/N)${NC}"
                read -rp "请确认: " confirm_clear
                if [[ "$confirm_clear" =~ ^[Yy]$ ]]; then
                    SFTP_HOST=""
                    SFTP_USERNAME=""
                    SFTP_PASSWORD=""
                    SFTP_PORT=22
                    SFTP_BACKUP_PATH=""
                    BACKUP_TARGET_SFTP="false"
                    save_config
                    log_and_display "${GREEN}SFTP 账号配置已清除。${NC}"
                else
                    log_and_display "取消清除 SFTP 账号配置。" "${BLUE}"
                fi
                press_enter_to_continue
                ;;
            0)
                log_and_display "返回云存储设定主菜单。" "${BLUE}"
                break
                ;;
            *)
                log_and_display "${RED}无效的选项，请重新输入。${NC}"
                press_enter_to_continue
                ;;
        esac
    done
}

# 选择要使用的云存储目标
select_backup_targets() {
    while true; do
        display_header
        echo -e "${BLUE}=== 选择云备份目标 ===${NC}"
        echo "请选择要用于备份的云存储 (可多选，至少选择一个有效目标)："
        echo "------------------------------------------------"

        local s3_configured="false"
        local webdav_configured="false"
        local ftp_configured="false"
        local ftps_configured="false"
        local sftp_configured="false"

        # 检查 S3/R2 配置状态
        if [[ -n "$S3_ACCESS_KEY" && -n "$S3_SECRET_KEY" && -n "$S3_ENDPOINT" && -n "$S3_BUCKET_NAME" && -n "$S3_BACKUP_PATH" ]]; then
            s3_configured="true"
            echo -n "1. S3/R2 存储 (当前: "
            if [[ "$BACKUP_TARGET_S3" == "true" ]]; then echo -e "${GREEN}启用${NC})"
            else echo -e "${YELLOW}禁用${NC})" ; fi
            echo "    (已配置账号并设置路径: ${S3_BACKUP_PATH})"
        else
            echo -e "1. S3/R2 存储 (${RED}未完全配置，无法启用${NC})"
        fi

        # 检查 WebDAV 配置状态
        if [[ -n "$WEBDAV_URL" && -n "$WEBDAV_USERNAME" && -n "$WEBDAV_PASSWORD" && -n "$WEBDAV_BACKUP_PATH" ]]; then
            webdav_configured="true"
            echo -n "2. WebDAV 存储 (当前: "
            if [[ "$BACKUP_TARGET_WEBDAV" == "true" ]]; then echo -e "${GREEN}启用${NC})"
            else echo -e "${YELLOW}禁用${NC})" ; fi
            echo "    (已配置账号并设置路径: ${WEBDAV_BACKUP_PATH})"
        else
            echo -e "2. WebDAV 存储 (${RED}未完全配置，无法启用${NC})"
        fi

        # --- 新增 FTP/FTPS/SFTP 目标选择 ---
        if [[ -n "$FTP_HOST" && -n "$FTP_USERNAME" && -n "$FTP_PASSWORD" && -n "$FTP_BACKUP_PATH" ]]; then
            ftp_configured="true"
            echo -n "3. FTP 存储 (当前: "
            if [[ "$BACKUP_TARGET_FTP" == "true" ]]; then echo -e "${GREEN}启用${NC})"
            else echo -e "${YELLOW}禁用${NC})" ; fi
            echo "    (已配置账号并设置路径: ${FTP_BACKUP_PATH})"
        else
            echo -e "3. FTP 存储 (${RED}未完全配置，无法启用${NC})"
        fi

        if [[ -n "$FTPS_HOST" && -n "$FTPS_USERNAME" && -n "$FTPS_PASSWORD" && -n "$FTPS_BACKUP_PATH" ]]; then
            ftps_configured="true"
            echo -n "4. FTPS 存储 (当前: "
            if [[ "$BACKUP_TARGET_FTPS" == "true" ]]; then echo -e "${GREEN}启用${NC})"
            else echo -e "${YELLOW}禁用${NC})" ; fi
            echo "    (已配置账号并设置路径: ${FTPS_BACKUP_PATH})"
        else
            echo -e "4. FTPS 存储 (${RED}未完全配置，无法启用${NC})"
        fi

        if [[ -n "$SFTP_HOST" && -n "$SFTP_USERNAME" && -n "$SFTP_PASSWORD" && -n "$SFTP_BACKUP_PATH" ]]; then
            sftp_configured="true"
            echo -n "5. SFTP 存储 (当前: "
            if [[ "$BACKUP_TARGET_SFTP" == "true" ]]; then echo -e "${GREEN}启用${NC})"
            else echo -e "${YELLOW}禁用${NC})" ; fi
            echo "    (已配置账号并设置路径: ${SFTP_BACKUP_PATH})"
        else
            echo -e "5. SFTP 存储 (${RED}未完全配置，无法启用${NC})"
        fi

        echo ""
        echo "0. 返回主菜单 (保存选择)"
        echo -e "${BLUE}------------------------------------------------${NC}"
        read -rp "请输入选项 (例如 '1', '2 3', '0'): " choice_input

        # Reset temporary targets based on current state before processing new input
        local temp_s3_target="$BACKUP_TARGET_S3"
        local temp_webdav_target="$BACKUP_TARGET_WEBDAV"
        local temp_ftp_target="$BACKUP_TARGET_FTP"
        local temp_ftps_target="$BACKUP_TARGET_FTPS"
        local temp_sftp_target="$BACKUP_TARGET_SFTP"

        # Initialize to false for fresh selection if user is providing specific numbers
        # If user inputs "1 3", only 1 and 3 should be true, others false.
        # If user inputs "0", keep current.
        if [[ "$choice_input" =~ [1-5] ]]; then # If any target number is chosen, reset all to false first
            temp_s3_target="false"
            temp_webdav_target="false"
            temp_ftp_target="false"
            temp_ftps_target="false"
            temp_sftp_target="false"
        fi

        local selections=($choice_input) # Split input into an array

        for sel in "${selections[@]}"; do
            case "$sel" in
                "1")
                    if [[ "$s3_configured" == "true" ]]; then
                        temp_s3_target="true"
                        log_and_display "已选择启用 S3/R2 备份。" "${GREEN}"
                    else
                        log_and_display "${RED}S3/R2 未完全配置，无法启用。${NC}"
                    fi
                    ;;
                "2")
                    if [[ "$webdav_configured" == "true" ]]; then
                        temp_webdav_target="true"
                        log_and_display "已选择启用 WebDAV 备份。" "${GREEN}"
                    else
                        log_and_display "${RED}WebDAV 未完全配置，无法启用。${NC}"
                    fi
                    ;;
                "3")
                    if [[ "$ftp_configured" == "true" ]]; then
                        temp_ftp_target="true"
                        log_and_display "已选择启用 FTP 备份。" "${GREEN}"
                    else
                        log_and_display "${RED}FTP 未完全配置，无法启用。${NC}"
                    fi
                    ;;
                "4")
                    if [[ "$ftps_configured" == "true" ]]; then
                        temp_ftps_target="true"
                        log_and_display "已选择启用 FTPS 备份。" "${GREEN}"
                    else
                        log_and_display "${RED}FTPS 未完全配置，无法启用。${NC}"
                    fi
                    ;;
                "5")
                    if [[ "$sftp_configured" == "true" ]]; then
                        temp_sftp_target="true"
                        log_and_display "已选择启用 SFTP 备份。" "${GREEN}"
                    else
                        log_and_display "${RED}SFTP 未完全配置，无法启用。${NC}"
                    fi
                    ;;
                "0") # Only if '0' is the only input
                    if [ "${#selections[@]}" -eq 1 ]; then
                        # If 0 is chosen alone, break out and save current state (which was possibly modified by other numbers if multi-select was intented)
                        # Or, if no specific targets were chosen, ensure all are false before breaking.
                        break
                    else
                        log_and_display "${RED}无效的选项组合。'0' 只能单独使用。${NC}"
                        temp_s3_target="$BACKUP_TARGET_S3" # Revert to previous state
                        temp_webdav_target="$BACKUP_TARGET_WEBDAV"
                        temp_ftp_target="$BACKUP_TARGET_FTP"
                        temp_ftps_target="$BACKUP_TARGET_FTPS"
                        temp_sftp_target="$BACKUP_TARGET_SFTP"
                    fi
                    ;;
                *)
                    log_and_display "${RED}无效的选项 '${sel}'，请重新输入。${NC}"
                    temp_s3_target="$BACKUP_TARGET_S3" # Revert to previous state
                    temp_webdav_target="$BACKUP_TARGET_WEBDAV"
                    temp_ftp_target="$BACKUP_TARGET_FTP"
                    temp_ftps_target="$BACKUP_TARGET_FTPS"
                    temp_sftp_target="$BACKUP_TARGET_SFTP"
                    ;;
            esac
        done

        if [ "$choice_input" == "0" ] || [[ "$choice_input" =~ [1-5] ]]; then # If user selected 0 or any numbers, proceed to save
            local any_target_enabled="false"
            if [[ "$temp_s3_target" == "true" || "$temp_webdav_target" == "true" || "$temp_ftp_target" == "true" || "$temp_ftps_target" == "true" || "$temp_sftp_target" == "true" ]]; then
                any_target_enabled="true"
            fi

            if [[ "$any_target_enabled" == "false" ]]; then
                log_and_display "${RED}警告：未选择任何有效备份目标。这会导致自动备份无法上传文件。${NC}"
                read -rp "确定要不选择任何目标吗？(y/N): " confirm_none
                if [[ ! "$confirm_none" =~ ^[Yy]$ ]]; then
                    continue # 重新显示菜单
                fi
            fi

            BACKUP_TARGET_S3="$temp_s3_target"
            BACKUP_TARGET_WEBDAV="$temp_webdav_target"
            BACKUP_TARGET_FTP="$temp_ftp_target"
            BACKUP_TARGET_FTPS="$temp_ftps_target"
            BACKUP_TARGET_SFTP="$temp_sftp_target"
            save_config
            log_and_display "备份目标设置已保存。" "${BLUE}"
            break # Exit the while loop
        fi
        press_enter_to_continue
    done
}


# 5. 云存储设定
set_cloud_storage() {
    while true; do
        display_header
        echo -e "${BLUE}=== 5. 云存储设定 ===${NC}"

        local s3_info="${RED}未配置${NC}"
        if [[ -n "$S3_ACCESS_KEY" && -n "$S3_BUCKET_NAME" ]]; then
            s3_info="${GREEN}已配置${NC} (桶: ${S3_BUCKET_NAME} | 路径: ${S3_BACKUP_PATH:-未设置})"
        fi

        local webdav_info="${RED}未配置${NC}"
        if [[ -n "$WEBDAV_URL" && -n "$WEBDAV_USERNAME" ]]; then
            local display_url="${WEBDAV_URL}"
            display_url="${display_url/:\/\/www./:\/\/\*\*\*./}"
            webdav_info="${GREEN}已配置${NC} (URL: ${display_url} | 用户名: ${WEBDAV_USERNAME} | 路径: ${WEBDAV_BACKUP_PATH:-未设置})"
        fi

        local ftp_info="${RED}未配置${NC}"
        if [[ -n "$FTP_HOST" && -n "$FTP_USERNAME" ]]; then
            ftp_info="${GREEN}已配置${NC} (主机: ${FTP_HOST}:${FTP_PORT} | 用户名: ${FTP_USERNAME} | 路径: ${FTP_BACKUP_PATH:-未设置})"
        fi

        local ftps_info="${RED}未配置${NC}"
        if [[ -n "$FTPS_HOST" && -n "$FTPS_USERNAME" ]]; then
            ftps_info="${GREEN}已配置${NC} (主机: ${FTPS_HOST}:${FTPS_PORT} | 用户名: ${FTPS_USERNAME} | 路径: ${FTPS_BACKUP_PATH:-未设置})"
        fi

        local sftp_info="${RED}未配置${NC}"
        if [[ -n "$SFTP_HOST" && -n "$SFTP_USERNAME" ]]; then
            sftp_info="${GREEN}已配置${NC} (主机: ${SFTP_HOST}:${SFTP_PORT} | 用户名: ${SFTP_USERNAME} | 路径: ${SFTP_BACKUP_PATH:-未设置})"
        fi

        echo "1. 选择云备份目标 (S3/R2: ${BACKUP_TARGET_S3}, WebDAV: ${BACKUP_TARGET_WEBDAV}, FTP: ${BACKUP_TARGET_FTP}, FTPS: ${BACKUP_TARGET_FTPS}, SFTP: ${BACKUP_TARGET_SFTP})"
        echo "    当前S3/R2账号: $s3_info"
        echo "    当前WebDAV账号: $webdav_info"
        echo "    当前FTP账号: $ftp_info"
        echo "    当前FTPS账号: $ftps_info"
        echo "    当前SFTP账号: $sftp_info"
        echo "2. 管理 S3/R2 账号设置"
        echo "3. 管理 WebDAV 账号设置"
        echo "4. 管理 FTP 账号设置"
        echo "5. 管理 FTPS 账号设置"
        echo "6. 管理 SFTP 账号设置"
        echo "0. 返回主菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"
        read -rp "请输入选项: " sub_choice

        case $sub_choice in
            1) select_backup_targets ;;
            2) manage_s3_r2_account ;;
            3) manage_webdav_account ;;
            4) manage_ftp_account ;;
            5) manage_ftps_account ;;
            6) manage_sftp_account ;;
            0)
                log_and_display "返回主菜单。" "${BLUE}"
                break
                ;;
            *)
                log_and_display "${RED}无效的选项，请重新输入。${NC}"
                press_enter_to_continue
                ;;
        esac
    done
}

# 6. 设置 Telegram 通知设定 (保持不变)
set_telegram_notification() {
    display_header
    echo -e "${BLUE}=== 6. 消息通知设定 (Telegram) ===${NC}"
    log_and_display "${YELLOW}Telegram Bot Token 和 Chat ID 将保存到本地配置文件，请确保配置文件安全！${NC}"
    read -rp "请输入 Telegram Bot Token (例如 123456:ABC-DEF1234ghIkl-79f): " TELEGRAM_BOT_TOKEN
    read -rp "请输入 Telegram Chat ID (例如 -123456789 或 123456789): " TELEGRAM_CHAT_ID
    save_config # 保存凭证到配置文件
    log_and_display "${GREEN}Telegram 通知配置已更新并保存。${NC}"
    log_and_display "${YELLOW}提示：您可以向 @BotFather 获取 Bot Token，然后向您的 Bot 发送消息，再访问 https://api.telegram.org/bot<YOUR_BOT_TOKEN>/getUpdates 获取 Chat ID。${NC}"
    press_enter_to_continue
}

# 7. 设置备份保留策略 (保持不变)
set_retention_policy() {
    while true; do
        display_header
        echo -e "${BLUE}=== 7. 设置备份保留策略 (云端) ===${NC}"
        echo "当前策略: "
        case "$RETENTION_POLICY_TYPE" in
            "none") echo -e "  ${YELLOW}无保留策略（所有备份将保留）${NC}" ;;
            "count") echo -e "  ${YELLOW}保留最新 ${RETENTION_VALUE} 个备份${NC}" ;;
            "days")  echo -e "  ${YELLOW}保留最近 ${RETENTION_VALUE} 天内的备份${NC}" ;;
            *)       echo -e "  ${YELLOW}未知策略或未设置${NC}" ;; # 添加默认情况
        esac
        echo ""
        echo "1. 设置按数量保留 (例如：保留最新的 5 个备份)"
        echo "2. 设置按天数保留 (例如：保留最近 30 天内的备份)"
        echo "3. 关闭保留策略"
        echo "0. 返回主菜单"
        echo -e "${BLUE}------------------------------------------------${NC}"
        read -rp "请输入选项: " sub_choice

        case $sub_choice in
            1)
                read -rp "请输入要保留的备份数量 (例如 5): " value_input
                if [[ "$value_input" =~ ^[0-9]+$ ]] && [ "$value_input" -ge 1 ]; then
                    RETENTION_POLICY_TYPE="count"
                    RETENTION_VALUE="$value_input"
                    save_config
                    log_and_display "${GREEN}已设置保留最新 ${RETENTION_VALUE} 个备份的策略。${NC}"
                else
                    log_and_display "${RED}输入无效，请输入一个大于等于 1 的整数。${NC}"
                fi
                press_enter_to_continue
                ;;
            2)
                read -rp "请输入要保留备份的天数 (例如 30): " value_input
                if [[ "$value_input" =~ ^[0-9]+$ ]] && [ "$value_input" -ge 1 ]; then
                    RETENTION_POLICY_TYPE="days"
                    RETENTION_VALUE="$value_input"
                    save_config
                    log_and_display "${GREEN}已设置保留最近 ${RETENTION_VALUE} 天内的备份策略。${NC}"
                else
                    log_and_display "${RED}输入无效，请输入一个大于等于 1 的整数。${NC}"
                fi
                press_enter_to_continue
                ;;
            3)
                RETENTION_POLICY_TYPE="none"
                RETENTION_VALUE=0
                save_config
                log_and_display "${GREEN}已关闭备份保留策略。${NC}"
                press_enter_to_continue
                ;;
            0)
                log_and_display "返回主菜单。" "${BLUE}"
                break
                ;;
            *)
                log_and_display "${RED}无效的选项，请重新输入。${NC}"
                press_enter_to_continue
                ;;
        esac
    done
}


# 应用保留策略的函数 (适应新的命名规则)
apply_retention_policy() {
    log_and_display "${BLUE}--- 正在应用备份保留策略 ---${NC}"

    if [[ "$RETENTION_POLICY_TYPE" == "none" ]]; then
        log_and_display "未设置保留策略，跳过清理。" "${YELLOW}"
        return 0
    fi

    local current_timestamp=$(date +%s)
    local total_s3_backups_found=0
    local deleted_s3_count=0
    local total_webdav_backups_found=0
    local deleted_webdav_count=0
    local total_ftp_backups_found=0
    local deleted_ftp_count=0
    local total_ftps_backups_found=0
    local deleted_ftps_count=0
    local total_sftp_backups_found=0
    local deleted_sftp_count=0

    # Function to delete a file from a specific service
    delete_file() {
        local service_type="$1"
        local file_to_delete="$2"
        local delete_status=1
        case "$service_type" in
            "s3")
                export AWS_ACCESS_KEY_ID="$S3_ACCESS_KEY"
                export AWS_SECRET_ACCESS_KEY="$S3_SECRET_KEY"
                if command -v aws &> /dev/null; then
                    aws s3 rm "s3://${S3_BUCKET_NAME}/${S3_BACKUP_PATH}${file_to_delete}" --endpoint-url "$S3_ENDPOINT" &> /dev/null
                    delete_status=$?
                elif command -v s3cmd &> /dev/null; then
                    s3cmd del "s3://${S3_BUCKET_NAME}/${S3_BACKUP_PATH}${file_to_delete}" &> /dev/null
                    delete_status=$?
                fi
                unset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY
                ;;
            "webdav")
                curl -s -k --user "$WEBDAV_USERNAME:$WEBDAV_PASSWORD" -X DELETE "${WEBDAV_URL%/}/${WEBDAV_BACKUP_PATH}${file_to_delete}" > /dev/null
                delete_status=$?
                ;;
            "ftp")
                lftp -u "$FTP_USERNAME","$FTP_PASSWORD" -p "$FTP_PORT" "$FTP_HOST" -e "rm ${FTP_BACKUP_PATH}${file_to_delete}; quit;" &> /dev/null
                delete_status=$?
                ;;
            "ftps")
                lftp -u "$FTPS_USERNAME","$FTPS_PASSWORD" -p "$FTPS_PORT" ftps://"$FTPS_HOST" -e "rm ${FTPS_BACKUP_PATH}${file_to_delete}; quit;" &> /dev/null
                delete_status=$?
                ;;
            "sftp")
                if command -v sshpass &> /dev/null; then
                    sshpass -p "$SFTP_PASSWORD" sftp -oBatchMode=no -b - -P "$SFTP_PORT" "$SFTP_USERNAME@$SFTP_HOST" <<< "rm ${SFTP_BACKUP_PATH}${file_to_delete}" &> /dev/null
                    delete_status=$?
                else
                    log_and_display "${RED}SFTP 删除失败：未找到 sshpass 命令。${NC}" "" "/dev/stderr"
                    delete_status=1 # Indicate failure
                fi
                ;;
        esac
        return "$delete_status"
    }

    # Generic function to process backups for a given service
    process_service_retention() {
        local service_type="$1" # e.g., "s3", "webdav", "ftp", "ftps", "sftp"
        local get_folders_cmd="$2" # Command to list files, e.g., "get_s3_r2_folders"
        local target_path_var_name="$3" # Name of the target path variable, e.g., "S3_BACKUP_PATH"
        local -n total_backups_found_ref="$4" # Reference to total_xxx_backups_found
        local -n deleted_count_ref="$5" # Reference to deleted_xxx_count

        local service_display_name=""
        local target_path=""
        local backups_array=()
        local client_found_status="false" # Used for S3 only

        case "$service_type" in
            "s3") service_display_name="S3/R2"; client_found_status="$s3_client_found" ;; # $s3_client_found is from main retention logic
            "webdav") service_display_name="WebDAV" ;;
            "ftp") service_display_name="FTP" ;;
            "ftps") service_display_name="FTPS" ;;
            "sftp") service_display_name="SFTP" ;;
        esac

        eval "target_path=\$$target_path_var_name" # Get value of target path variable

        log_and_display "正在检查 ${service_display_name} 存储中的旧备份：${target_path}..."

        local raw_backups_list=$($get_folders_cmd 2>/dev/null) # Capture stdout only
        if [ $? -ne 0 ] && [ -z "$raw_backups_list" ]; then # If command failed AND no output
             log_and_display "${YELLOW}${service_display_name} 未启用为备份目标或配置不完整/连接失败，跳过清理。${NC}"
             return
        fi

        # Filter out directories if any were returned (some ls commands might return them)
        # And ensure only zip files matching the pattern are considered
        mapfile -t backups_array <<< "$(echo "$raw_backups_list" | grep -E '^[a-zA-Z0-9_-]+_[0-9]{14}\.zip$')"
        
        total_backups_found_ref=${#backups_array[@]}

        if [ ${#backups_array[@]} -eq 0 ]; then
            log_and_display "${YELLOW}${service_display_name} 存储中的指定路径 '${target_path}' 未找到备份文件，或工具未正确配置/权限不足。${NC}"
        else
            IFS=$'\n' backups_array=($(sort <<<"${backups_array[*]}")) # 按时间正序排序 (最旧的在前)
            unset IFS

            if [[ "$RETENTION_POLICY_TYPE" == "count" ]]; then
                log_and_display "${service_display_name} 保留策略: 保留最新 ${RETENTION_VALUE} 个备份。"
                local num_to_delete=$(( ${#backups_array[@]} - RETENTION_VALUE ))
                if [ "$num_to_delete" -gt 0 ]; then
                    log_and_display "${service_display_name}: 发现 ${num_to_delete} 个备份超过保留数量，将删除最旧的 ${num_to_delete} 个。" "${YELLOW}"
                    for (( i=0; i<num_to_delete; i++ )); do
                        local file_to_delete="${backups_array[$i]}"
                        log_and_display "${service_display_name}: 正在删除旧备份: ${file_to_delete}" "${YELLOW}"
                        if delete_file "$service_type" "$file_to_delete"; then
                            deleted_count_ref=$((deleted_count_ref + 1))
                        fi
                    done
                    log_and_display "${GREEN}${service_display_name} 旧备份清理完成。已删除 ${deleted_count_ref} 个文件。${NC}"
                else
                    log_and_display "${service_display_name} 中备份数量 (${total_backups_found_ref} 个) 未超过保留限制 (${RETENTION_VALUE} 个)，无需清理。" "${BLUE}"
                fi
            elif [[ "$RETENTION_POLICY_TYPE" == "days" ]]; then
                log_and_display "${service_display_name} 保留策略: 保留最近 ${RETENTION_VALUE} 天内的备份。"
                local cutoff_timestamp=$(( current_timestamp - RETENTION_VALUE * 24 * 3600 ))
                local files_to_delete=()
                for backup_file in "${backups_array[@]}"; do
                    local backup_date_str=$(echo "$backup_file" | sed -E 's/.*_([0-9]{14})\.zip/\1/')
                    local backup_timestamp=$(date -d "${backup_date_str:0:8} ${backup_date_str:8:2}:${backup_date_str:10:2}:${backup_date_str:12:2}" +%s 2>/dev/null)

                    if [[ "$backup_timestamp" -ne 0 && "$backup_timestamp" -lt "$cutoff_timestamp" ]]; then
                        files_to_delete+=("$backup_file")
                    fi
                done

                if [ ${#files_to_delete[@]} -gt 0 ]; then
                    log_and_display "${service_display_name}: 发现 ${#files_to_delete[@]} 个备份超过 ${RETENTION_VALUE} 天，将进行删除。" "${YELLOW}"
                    for file_to_delete in "${files_to_delete[@]}"; do
                        local delete_timestamp=$(echo "$file_to_delete" | sed -E 's/.*_([0-9]{14})\.zip/\1/')
                        local display_delete_date=$(date -d "${delete_timestamp:0:8} ${delete_timestamp:8:2}:${delete_timestamp:10:2}:${delete_timestamp:12:2}" '+%Y-%m-%d %H:%M:%S' 2>/dev/null)
                        log_and_display "${service_display_name}: 正在删除旧备份: ${file_to_delete} (创建于 ${display_delete_date})" "${YELLOW}"
                        if delete_file "$service_type" "$file_to_delete"; then
                            deleted_count_ref=$((deleted_count_ref + 1))
                        fi
                    done
                    log_and_display "${GREEN}${service_display_name} 旧备份清理完成。已删除 ${deleted_count_ref} 个文件。${NC}"
                else
                    log_and_display "${service_display_name} 中没有超过 ${RETENTION_VALUE} 天的备份，无需清理。" "${BLUE}"
                fi
            fi
        fi
    }

    # Call process_service_retention for each enabled target
    if [[ "$BACKUP_TARGET_S3" == "true" ]]; then
        if [[ -n "$S3_ACCESS_KEY" && -n "$S3_SECRET_KEY" && -n "$S3_ENDPOINT" && -n "$S3_BUCKET_NAME" && -n "$S3_BACKUP_PATH" ]]; then
            process_service_retention "s3" "get_s3_r2_folders" "S3_BACKUP_PATH" total_s3_backups_found deleted_s3_count
        else
            log_and_display "${YELLOW}S3/R2 已启用为备份目标但配置不完整，跳过 S3/R2 备份清理。${NC}"
        fi
    fi

    if [[ "$BACKUP_TARGET_WEBDAV" == "true" ]]; then
        if [[ -n "$WEBDAV_URL" && -n "$WEBDAV_USERNAME" && -n "$WEBDAV_PASSWORD" && -n "$WEBDAV_BACKUP_PATH" ]]; then
            process_service_retention "webdav" "get_webdav_folders" "WEBDAV_BACKUP_PATH" total_webdav_backups_found deleted_webdav_count
        else
            log_and_display "${YELLOW}WebDAV 已启用为备份目标但配置不完整，跳过 WebDAV 备份清理。${NC}"
        fi
    fi

    if [[ "$BACKUP_TARGET_FTP" == "true" ]]; then
        if [[ -n "$FTP_HOST" && -n "$FTP_USERNAME" && -n "$FTP_PASSWORD" && -n "$FTP_BACKUP_PATH" ]]; then
            process_service_retention "ftp" "get_ftp_folders" "FTP_BACKUP_PATH" total_ftp_backups_found deleted_ftp_count
        else
            log_and_display "${YELLOW}FTP 已启用为备份目标但配置不完整，跳过 FTP 备份清理。${NC}"
        fi
    fi

    if [[ "$BACKUP_TARGET_FTPS" == "true" ]]; then
        if [[ -n "$FTPS_HOST" && -n "$FTPS_USERNAME" && -n "$FTPS_PASSWORD" && -n "$FTPS_BACKUP_PATH" ]]; then
            process_service_retention "ftps" "get_ftps_folders" "FTPS_BACKUP_PATH" total_ftps_backups_found deleted_ftps_count
        else
            log_and_display "${YELLOW}FTPS 已启用为备份目标但配置不完整，跳过 FTPS 备份清理。${NC}"
        fi
    fi

    if [[ "$BACKUP_TARGET_SFTP" == "true" ]]; then
        if [[ -n "$SFTP_HOST" && -n "$SFTP_USERNAME" && -n "$SFTP_PASSWORD" && -n "$SFTP_BACKUP_PATH" ]]; then
            if command -v sshpass &> /dev/null; then
                process_service_retention "sftp" "get_sftp_folders" "SFTP_BACKUP_PATH" total_sftp_backups_found deleted_sftp_count
            else
                log_and_display "${RED}SFTP 已启用为备份目标，但未找到 sshpass 命令，SFTP 清理功能将被跳过。${NC}"
            fi
        else
            log_and_display "${YELLOW}SFTP 已启用为备份目标但配置不完整，跳过 SFTP 备份清理。${NC}"
        fi
    fi

    local retention_summary="保留策略执行完毕。"
    retention_summary+="\nS3/R2: 找到 ${total_s3_backups_found} 个，删除了 ${deleted_s3_count} 个。"
    retention_summary+="\nWebDAV: 找到 ${total_webdav_backups_found} 个，删除了 ${deleted_webdav_count} 个。"
    retention_summary+="\nFTP: 找到 ${total_ftp_backups_found} 个，删除了 ${deleted_ftp_count} 个。"
    retention_summary+="\nFTPS: 找到 ${total_ftps_backups_found} 个，删除了 ${deleted_ftps_count} 个。"
    retention_summary+="\nSFTP: 找到 ${total_sftp_backups_found} 个，删除了 ${deleted_sftp_count} 个。"
    send_telegram_message "*个人自用数据备份：保留策略完成*\n${retention_summary}"
    log_and_display "${BLUE}--- 备份保留策略应用结束 ---${NC}"
}


# 执行备份上传的核心逻辑 (大幅修改以支持多路径独立备份)
# 参数 1: 备份类型 (例如，"手动备份", "自动备份")
perform_backup() {
    local backup_type="$1"
    local readable_time=$(date '+%Y-%m-%d %H:%M:%S')
    local overall_status="失败"
    local overall_succeeded_count=0
    local total_paths_to_backup=${#BACKUP_SOURCE_PATHS_ARRAY[@]}

    log_and_display "${BLUE}--- ${backup_type} 过程开始 ---${NC}"

    local initial_message="*个人自用数据备份：开始 (${backup_type})*\n时间: ${readable_time}\n将备份 ${total_paths_to_backup} 个路径。"
    send_telegram_message "${initial_message}"

    if [ ${#BACKUP_SOURCE_PATHS_ARRAY[@]} -eq 0 ]; then
        log_and_display "${RED}错误：没有设置任何备份源路径。请先通过 '3. 自定义备份路径' 添加路径。${NC}"
        send_telegram_message "*个人自用数据备份：失败*\n原因: 未设置备份源路径。"
        return 1
    fi

    # 遍历每个备份源路径
    for i in "${!BACKUP_SOURCE_PATHS_ARRAY[@]}"; do
        local current_backup_path="${BACKUP_SOURCE_PATHS_ARRAY[$i]}"
        local path_display_name=$(basename "$current_backup_path") # 用于显示友好的路径名
        local timestamp=$(date +%Y%m%d%H%M%S)

        # 清理路径名，使其适合作为文件名 (替换非字母数字下划线连字符为下划线)
        local sanitized_path_name=$(echo "$path_display_name" | sed 's/[^a-zA-Z0-9_-]/_/g')
        # 确保文件名不会以点开头，或者有连续的点
        sanitized_path_name=$(echo "$sanitized_path_name" | sed 's/^\.//; s/\.\./_/g')
        # 如果处理后为空，则使用通用名加索引
        if [[ -z "$sanitized_path_name" ]]; then
            sanitized_path_name="backup_item_${i}"
        fi

        local archive_name="${sanitized_path_name}_${timestamp}.zip"
        local temp_archive_path="${TEMP_DIR}/${archive_name}"
        local backup_file_size="未知"
        local current_path_upload_status="失败" # 记录当前路径的上传状态
        local any_upload_succeeded_for_path="false" # Track if any upload succeeded for this specific path

        log_and_display "${BLUE}--- 正在处理路径 $((i+1))/${total_paths_to_backup}: ${current_backup_path} ---${NC}"

        if [[ ! -d "$current_backup_path" && ! -f "$current_backup_path" ]]; then
            log_and_display "${RED}错误：路径 '$current_backup_path' 无效或不存在，跳过此路径备份。${NC}"
            send_telegram_message "*个人自用数据备份：路径失败*\n路径: \`${current_backup_path}\`\n原因: 路径无效或不存在。"
            continue # 跳过当前路径，继续下一个
        fi

        # --- 压缩文件 ---
        log_and_display "正在压缩路径 '$current_backup_path' 到文件 '$archive_name'..."
        local zip_command_status=1 # 默认为失败
        local zip_output="" # Capture all output (stdout and stderr)

        if [[ -d "$current_backup_path" ]]; then
            # 压缩目录，只包含目录内的内容，不包含父目录本身
            # zip 的 -j 选项用于只存储文件名，不包括目录结构。这里需要包含目录结构。
            # 切换到父目录，然后压缩子目录
            zip_output=$( (cd "$(dirname "$current_backup_path")" && zip -r "$temp_archive_path" "$(basename "$current_backup_path")") 2>&1 )
            zip_command_status=$?
        elif [[ -f "$current_backup_path" ]]; then
            # 压缩单个文件
            zip_output=$(zip "$temp_archive_path" "$current_backup_path" 2>&1)
            zip_command_status=$?
        fi

        if [ "$zip_command_status" -eq 0 ]; then
            log_and_display "${GREEN}文件压缩成功！${NC}"
            if [[ -f "$temp_archive_path" ]]; then
                backup_file_size=$(du -h "$temp_archive_path" | awk '{print $1}')
            else
                backup_file_size="未知 (压缩文件未生成)"
                log_and_display "${RED}警告：压缩成功但未找到生成的临时文件：$temp_archive_path${NC}"
            fi
        else
            log_and_display "${RED}文件压缩失败！请检查路径权限或磁盘空间。错误码: ${zip_command_status}${NC}"
            send_telegram_message "*个人自用数据备份：压缩失败*\n路径: \`${current_backup_path}\`\n文件: \`${archive_name}\`\n原因: 压缩失败，错误码: ${zip_command_status}\n详细错误: \`${zip_output}\`"
            rm -f "$temp_archive_path" 2>/dev/null # 尝试清理失败的临时文件
            continue # 跳过当前路径的上传，继续下一个
        fi

        # Store upload statuses for current path
        local s3_this_upload_status="未尝试"
        local webdav_this_upload_status="未尝试"
        local ftp_this_upload_status="未尝试"
        local ftps_this_upload_status="未尝试"
        local sftp_this_upload_status="未尝试"


        # --- 上传到 S3/R2 ---
        if [[ "$BACKUP_TARGET_S3" == "true" ]]; then
            if [[ -n "$S3_ACCESS_KEY" && -n "$S3_SECRET_KEY" && -n "$S3_ENDPOINT" && -n "$S3_BUCKET_NAME" && -n "$S3_BACKUP_PATH" ]]; then
                log_and_display "正在尝试上传到 S3/R2 存储桶：${S3_BUCKET_NAME}/${S3_BACKUP_PATH}${archive_name}..."
                local s3_upload_output=""
                local s3_upload_status_code=1

                export AWS_ACCESS_KEY_ID="$S3_ACCESS_KEY"
                export AWS_SECRET_ACCESS_KEY="$S3_SECRET_KEY"

                if command -v aws &> /dev/null; then
                    s3_upload_output=$(aws s3 cp "$temp_archive_path" "s3://${S3_BUCKET_NAME}/${S3_BACKUP_PATH}${archive_name}" --endpoint-url "$S3_ENDPOINT" 2>&1)
                    s3_upload_status_code=$?
                elif command -v s3cmd &> /dev/null; then
                    s3_upload_output=$(s3cmd put "$temp_archive_path" "s3://${S3_BUCKET_NAME}/${S3_BACKUP_PATH}${archive_name}" 2>&1)
                    s3_upload_status_code=$?
                fi
                unset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY

                if [ "$s3_upload_status_code" -eq 0 ]; then
                    log_and_display "${GREEN}S3/R2 上传成功！${NC}"
                    s3_this_upload_status="成功"
                    any_upload_succeeded_for_path="true"
                else
                    log_and_display "${RED}S3/R2 上传失败！错误信息: ${s3_upload_output}${NC}"
                    s3_this_upload_status="失败"
                fi
            else
                log_and_display "${RED}S3/R2 已设置为备份目标，但配置不完整。跳过 S3/R2 上传。${NC}"
                s3_this_upload_status="跳过 (配置不完整)"
            fi
        else
            log_and_display "${YELLOW}S3/R2 未设置为备份目标，跳过 S3/R2 上传。${NC}"
            s3_this_upload_status="禁用"
        fi

        # --- 上传到 WebDAV ---
        if [[ "$BACKUP_TARGET_WEBDAV" == "true" ]]; then
            if [[ -n "$WEBDAV_URL" && -n "$WEBDAV_USERNAME" && -n "$WEBDAV_PASSWORD" && -n "$WEBDAV_BACKUP_PATH" ]]; then
                log_and_display "正在尝试上传到 WebDAV 服务器：${WEBDAV_URL%/}/${WEBDAV_BACKUP_PATH}${archive_name}..."
                local webdav_upload_output=""
                local webdav_upload_status_code=1

                if command -v curl &> /dev/null; then
                    webdav_upload_output=$(curl -k --user "$WEBDAV_USERNAME:$WEBDAV_PASSWORD" --upload-file "$temp_archive_path" "${WEBDAV_URL%/}/${WEBDAV_BACKUP_PATH}${archive_name}" --fail --no-progress-meter 2>&1)
                    webdav_upload_status_code=$?
                fi

                if [ "$webdav_upload_status_code" -eq 0 ]; then
                    log_and_display "${GREEN}WebDAV 上传成功！${NC}"
                    webdav_this_upload_status="成功"
                    any_upload_succeeded_for_path="true"
                else
                    log_and_display "${RED}WebDAV 上传失败！错误信息: ${webdav_upload_output}${NC}"
                    webdav_this_upload_status="失败"
                fi
            else
                log_and_display "${RED}WebDAV 已设置为备份目标，但配置不完整。跳过 WebDAV 上传。${NC}"
                webdav_this_upload_status="跳过 (配置不完整)"
            fi
        else
            log_and_display "${YELLOW}WebDAV 未设置为备份目标，跳过 WebDAV 上传。${NC}"
            webdav_this_upload_status="禁用"
        fi

        # --- 新增 FTP 上传 ---
        if [[ "$BACKUP_TARGET_FTP" == "true" ]]; then
            if [[ -n "$FTP_HOST" && -n "$FTP_USERNAME" && -n "$FTP_PASSWORD" && -n "$FTP_BACKUP_PATH" ]]; then
                log_and_display "正在尝试上传到 FTP 服务器：${FTP_HOST}:${FTP_PORT}/${FTP_BACKUP_PATH}${archive_name}..."
                # lftp put命令，远程路径如果是目录，会自动使用同名文件
                if lftp -u "$FTP_USERNAME","$FTP_PASSWORD" -p "$FTP_PORT" "$FTP_HOST" -e "put '$temp_archive_path' -o ${FTP_BACKUP_PATH}${archive_name}; quit;" &> /dev/null; then
                    log_and_display "${GREEN}FTP 上传成功！${NC}"
                    ftp_this_upload_status="成功"
                    any_upload_succeeded_for_path="true"
                else
                    log_and_display "${RED}FTP 上传失败！请检查配置或网络连接。${NC}"
                    ftp_this_upload_status="失败"
                fi
            else
                log_and_display "${RED}FTP 已设置为备份目标，但配置不完整。跳过 FTP 上传。${NC}"
                ftp_this_upload_status="跳过 (配置不完整)"
            fi
        else
            log_and_display "${YELLOW}FTP 未设置为备份目标，跳过 FTP 上传。${NC}"
            ftp_this_upload_status="禁用"
        fi

        # --- 新增 FTPS 上传 ---
        if [[ "$BACKUP_TARGET_FTPS" == "true" ]]; then
            if [[ -n "$FTPS_HOST" && -n "$FTPS_USERNAME" && -n "$FTPS_PASSWORD" && -n "$FTPS_BACKUP_PATH" ]]; then
                log_and_display "正在尝试上传到 FTPS 服务器：${FTPS_HOST}:${FTPS_PORT}/${FTPS_BACKUP_PATH}${archive_name}..."
                if lftp -u "$FTPS_USERNAME","$FTPS_PASSWORD" -p "$FTPS_PORT" ftps://"$FTPS_HOST" -e "put '$temp_archive_path' -o ${FTPS_BACKUP_PATH}${archive_name}; quit;" &> /dev/null; then
                    log_and_display "${GREEN}FTPS 上传成功！${NC}"
                    ftps_this_upload_status="成功"
                    any_upload_succeeded_for_path="true"
                else
                    log_and_display "${RED}FTPS 上传失败！请检查配置或网络连接。${NC}"
                    ftps_this_upload_status="失败"
                fi
            else
                log_and_display "${RED}FTPS 已设置为备份目标，但配置不完整。跳过 FTPS 上传。${NC}"
                ftps_this_upload_status="跳过 (配置不完整)"
            fi
        else
            log_and_display "${YELLOW}FTPS 未设置为备份目标，跳过 FTPS 上传。${NC}"
            ftps_this_upload_status="禁用"
        fi

        # --- 新增 SFTP 上传 ---
        if [[ "$BACKUP_TARGET_SFTP" == "true" ]]; then
            if [[ -n "$SFTP_HOST" && -n "$SFTP_USERNAME" && -n "$SFTP_PASSWORD" && -n "$SFTP_BACKUP_PATH" ]]; then
                log_and_display "正在尝试上传到 SFTP 服务器：${SFTP_USERNAME}@${SFTP_HOST}:${SFTP_PORT}/${SFTP_BACKUP_PATH}${archive_name}..."
                if command -v sshpass &> /dev/null; then
                    if sshpass -p "$SFTP_PASSWORD" sftp -oBatchMode=no -b - -P "$SFTP_PORT" "$SFTP_USERNAME@$SFTP_HOST" <<< "put '$temp_archive_path' ${SFTP_BACKUP_PATH}${archive_name}" &> /dev/null; then
                        log_and_display "${GREEN}SFTP 上传成功！${NC}"
                        sftp_this_upload_status="成功"
                        any_upload_succeeded_for_path="true"
                    else
                        log_and_display "${RED}SFTP 上传失败！请检查配置、凭证或网络连接。${NC}"
                        sftp_this_upload_status="失败"
                    fi
                else
                    log_and_display "${RED}SFTP 上传失败：未找到 sshpass 命令。${NC}"
                    sftp_this_upload_status="跳过 (缺少 sshpass)"
                fi
            else
                log_and_display "${RED}SFTP 已设置为备份目标，但配置不完整。跳过 SFTP 上传。${NC}"
                sftp_this_upload_status="跳过 (配置不完整)"
            fi
        else
            log_and_display "${YELLOW}SFTP 未设置为备份目标，跳过 SFTP 上传。${NC}"
            sftp_this_upload_status="禁用"
        fi

        # 记录当前路径的整体上传状态
        if [[ "$any_upload_succeeded_for_path" == "true" ]]; then
            overall_succeeded_count=$((overall_succeeded_count + 1))
            current_path_upload_status="成功"
        else
            current_path_upload_status="失败"
        fi

        # 发送当前路径的详细 Telegram 通知
        local path_summary_message="*个人自用数据备份：路径完成 (${current_path_upload_status})*\n"
        path_summary_message+="路径: \`${current_backup_path}\`\n"
        path_summary_message+="备份文件: \`${archive_name}\`\n"
        path_summary_message+="文件大小: ${backup_file_size}\n"
        path_summary_message+="S3/R2 上传: ${s3_this_upload_status}"
        if [[ -n "$S3_BUCKET_NAME" && "$s3_this_upload_status" != "禁用" ]]; then path_summary_message+=" (目标: \`${S3_BUCKET_NAME}/${S3_BACKUP_PATH}\`)"; fi
        path_summary_message+="\n"
        path_summary_message+="WebDAV 上传: ${webdav_this_upload_status}"
        if [[ -n "$WEBDAV_URL" && "$webdav_this_upload_status" != "禁用" ]]; then path_summary_message+=" (目标: \`${WEBDAV_URL%/}/${WEBDAV_BACKUP_PATH}\`)"; fi
        path_summary_message+="\n"
        path_summary_message+="FTP 上传: ${ftp_this_upload_status}"
        if [[ -n "$FTP_HOST" && "$ftp_this_upload_status" != "禁用" ]]; then path_summary_message+=" (目标: \`${FTP_HOST}:${FTP_PORT}/${FTP_BACKUP_PATH}\`)"; fi
        path_summary_message+="\n"
        path_summary_message+="FTPS 上传: ${ftps_this_upload_status}"
        if [[ -n "$FTPS_HOST" && "$ftps_this_upload_status" != "禁用" ]]; then path_summary_message+=" (目标: \`${FTPS_HOST}:${FTPS_PORT}/${FTPS_BACKUP_PATH}\`)"; fi
        path_summary_message+="\n"
        path_summary_message+="SFTP 上传: ${sftp_this_upload_status}"
        if [[ -n "$SFTP_HOST" && "$sftp_this_upload_status" != "禁用" ]]; then path_summary_message+=" (目标: \`${SFTP_HOST}:${SFTP_PORT}/${SFTP_BACKUP_PATH}\`)"; fi
        send_telegram_message "${path_summary_message}"

        # 清理当前路径的临时压缩文件
        if [[ -f "$temp_archive_path" ]]; then
            log_and_display "正在清理临时压缩文件：$temp_archive_path"
            rm -f "$temp_archive_path"
            if [ $? -eq 0 ]; then
                log_and_display "${GREEN}临时文件清理完成。${NC}"
            else
                log_and_display "${RED}临时文件清理失败。${NC}"
            fi
        fi
    done # 结束所有路径的循环

    # 根据所有路径的备份结果确定整体状态
    if [ "$overall_succeeded_count" -eq "$total_paths_to_backup" ] && [ "$total_paths_to_backup" -gt 0 ]; then
        overall_status="全部成功"
    elif [ "$overall_succeeded_count" -gt 0 ]; then
        overall_status="部分成功"
    elif [ "$total_paths_to_backup" -eq 0 ]; then
        overall_status="未执行 (无备份路径)"
    else
        overall_status="全部失败"
    fi

    log_and_display "${BLUE}--- ${backup_type} 过程结束 ---${NC}"

    # 如果是自动备份，更新上次自动备份时间戳
    if [[ "$backup_type" == "自动备份 (Cron)" ]]; then
        LAST_AUTO_BACKUP_TIMESTAMP=$(date +%s)
        save_config # 保存更新后的时间戳 (这也会保存当前凭证)
        log_and_display "已更新上次自动备份时间戳：$(date -d @$LAST_AUTO_BACKUP_TIMESTAMP '+%Y-%m-%d %H:%M:%S')" "${BLUE}"
    fi

    # 发送最终的整体 Telegram 通知
    local final_overall_message="*个人自用数据备份：总览 (${overall_status})*\n"
    final_overall_message+="时间: ${readable_time}\n"
    final_overall_message+="类型: ${backup_type}\n"
    final_overall_message+="总路径数: ${total_paths_to_backup}\n"
    final_overall_message+="成功备份路径数: ${overall_succeeded_count}\n"
    send_telegram_message "${final_overall_message}"

    # 只有在至少一个上传尝试成功后才应用保留策略
    # 注意：保留策略现在会处理新命名的文件
    if [[ "$overall_succeeded_count" -gt 0 ]]; then
        apply_retention_policy
    else
        log_and_display "${YELLOW}由于没有成功的备份上传，跳过保留策略的执行。${NC}"
    fi
}

# 99. 卸载脚本 (保持不变)
uninstall_script() {
    display_header
    echo -e "${RED}=== 99. 卸载脚本 ===${NC}"
    log_and_display "${RED}警告：您确定要卸载脚本吗？这将删除所有脚本文件、配置文件和日志文件。（y/N）${NC}"
    read -rp "请确认 (y/N): " confirm

    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        log_and_display "${RED}开始卸载脚本...${NC}"
        local script_path="$(readlink -f "$0")" # 获取脚本的真实路径

        log_and_display "删除脚本文件：$script_path"
        rm -f "$script_path" 2>/dev/null

        if [[ -f "$CONFIG_FILE" ]]; then
            log_and_display "删除配置文件：$CONFIG_FILE"
            rm -f "$CONFIG_FILE" 2>/dev/null
        fi

        if [[ -d "$CONFIG_DIR" ]] && [ -z "$(ls -A "$CONFIG_DIR")" ]; then
            log_and_display "删除空配置目录：$CONFIG_DIR"
            rmdir "$CONFIG_DIR" 2>/dev/null
        fi

        if [[ -f "$LOG_FILE" ]]; then
            log_and_display "删除日志文件：$LOG_FILE"
            rm -f "$LOG_FILE" 2>/dev/null
        fi

        if [[ -d "$LOG_DIR" ]] && [ -z "$(ls -A "$LOG_DIR")" ]; then
            log_and_display "删除空日志目录：$LOG_DIR"
            rmdir "$LOG_DIR" 2>/dev/null
        fi

        log_and_display "${YELLOW}提示：如果此脚本是通过别名或放置在 PATH 中的文件启动的，您可能需要手动删除它们。${NC}"
        log_and_display "${GREEN}脚本卸载完成。${NC}"
        exit 0
    else
        log_and_display "取消卸载。" "${BLUE}"
    fi
    press_enter_to_continue
}

# --- 主菜单 ---
show_main_menu() {
    display_header
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━ 功能选项 ━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "  1. ${YELLOW}自动备份设定${NC} (当前间隔: ${AUTO_BACKUP_INTERVAL_DAYS} 天)${NC}"
    echo -e "  2. ${YELLOW}手动备份${NC}"
    echo -e "  3. ${YELLOW}自定义备份路径${NC} (当前数量: ${#BACKUP_SOURCE_PATHS_ARRAY[@]} 个)${NC}" # 显示路径数量
    echo -e "  4. ${YELLOW}压缩包格式${NC} (当前支持: ZIP)${NC}"
    echo -e "  5. ${YELLOW}云存储设定${NC} (支持: S3/R2, WebDAV, FTP, FTPS, SFTP)${NC}"
    echo -e "  6. ${YELLOW}消息通知设定${NC} (Telegram)${NC}"
    echo -e "  7. ${YELLOW}设置备份保留策略${NC} (云端)${NC}"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "  0. ${RED}退出脚本${NC}"
    echo -e "  99. ${RED}卸载脚本${NC}"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
}

# 处理菜单选择
process_menu_choice() {
    local choice
    read -rp "请输入选项: " choice
    log_and_display "用户选择: $choice"

    case $choice in
        1) set_auto_backup_interval ;;
        2) manual_backup ;;
        3) set_backup_path ;; # 调用新的多路径管理函数
        4) display_compression_info ;;
        5) set_cloud_storage ;;
        6) set_telegram_notification ;;
        7) set_retention_policy ;;
        0)
            log_and_display "${GREEN}感谢使用，再见！${NC}"
            exit 0
            ;;
        99) uninstall_script ;;
        *)
            log_and_display "${RED}无效的选项，请重新输入。${NC}"
            press_enter_to_continue
            ;;
    esac
}

# 检查是否应该运行自动备份 (根据间隔时间)
check_auto_backup() {
    load_config # 确保加载最新配置

    local current_timestamp=$(date +%s)
    local interval_seconds=$(( AUTO_BACKUP_INTERVAL_DAYS * 24 * 3600 )) # 将天数转换为秒

    # 检查是否有至少一个备份路径
    if [ ${#BACKUP_SOURCE_PATHS_ARRAY[@]} -eq 0 ]; then
        log_and_display "${RED}自动备份失败：没有设置任何备份源路径。请通过主菜单设置。${NC}"
        send_telegram_message "*个人自用数据备份：自动备份失败*\n原因: 未设置备份源路径。"
        return 1
    fi

    # 检查是否有至少一个启用的备份目标
    local any_target_enabled="false"
    if [[ "$BACKUP_TARGET_S3" == "true" && -n "$S3_ACCESS_KEY" && -n "$S3_SECRET_KEY" && -n "$S3_ENDPOINT" && -n "$S3_BUCKET_NAME" && -n "$S3_BACKUP_PATH" ]]; then any_target_enabled="true"; fi
    if [[ "$BACKUP_TARGET_WEBDAV" == "true" && -n "$WEBDAV_URL" && -n "$WEBDAV_USERNAME" && -n "$WEBDAV_PASSWORD" && -n "$WEBDAV_BACKUP_PATH" ]]; then any_target_enabled="true"; fi
    if [[ "$BACKUP_TARGET_FTP" == "true" && -n "$FTP_HOST" && -n "$FTP_USERNAME" && -n "$FTP_PASSWORD" && -n "$FTP_BACKUP_PATH" ]]; then any_target_enabled="true"; fi
    if [[ "$BACKUP_TARGET_FTPS" == "true" && -n "$FTPS_HOST" && -n "$FTPS_USERNAME" && -n "$FTPS_PASSWORD" && -n "$FTPS_BACKUP_PATH" ]]; then any_target_enabled="true"; fi
    # For SFTP, also check for sshpass if password is used, or rely on SSH keys
    if [[ "$BACKUP_TARGET_SFTP" == "true" && -n "$SFTP_HOST" && -n "$SFTP_USERNAME" && -n "$SFTP_PASSWORD" && -n "$SFTP_BACKUP_PATH" ]]; then
        if command -v sshpass &> /dev/null; then
            any_target_enabled="true"
        else
            log_and_display "${RED}SFTP 已启用但未找到 sshpass 命令，将无法进行密码认证的自动备份。请安装 sshpass 或使用 SSH 密钥。${NC}"
            # Don't set any_target_enabled to true for SFTP if sshpass is missing, to reflect inability to back up
        fi
    fi


    if [[ "$any_target_enabled" == "false" ]]; then
        log_and_display "${RED}自动备份失败：没有启用或配置完整的云存储目标。请通过 '5. 云存储设定' 进行配置。${NC}"
        send_telegram_message "*个人自用数据备份：自动备份失败*\n原因: 未启用或配置完整的云存储目标。"
        return 1
    fi


    if [[ "$LAST_AUTO_BACKUP_TIMESTAMP" -eq 0 ]]; then
        log_and_display "首次自动备份，或上次自动备份时间未记录，立即执行。" "${YELLOW}"
        perform_backup "自动备份 (Cron)"
    elif (( current_timestamp - LAST_AUTO_BACKUP_TIMESTAMP >= interval_seconds )); then
        log_and_display "距离上次自动备份已超过 ${AUTO_BACKUP_INTERVAL_DAYS} 天 (${interval_seconds} 秒)，执行自动备份。" "${BLUE}"
        perform_backup "自动备份 (Cron)"
    else
        local next_backup_time=$(( LAST_AUTO_BACKUP_TIMESTAMP + interval_seconds ))
        local remaining_seconds=$(( next_backup_time - current_timestamp ))
        local remaining_days=$(( remaining_seconds / 86400 ))
        local remaining_hours=$(( (remaining_seconds % 86400) / 3600 ))
        log_and_display "未到自动备份时间。距离下次备份还有约 ${remaining_days} 天 ${remaining_hours} 小时。" "${YELLOW}"
    fi
}

# --- 脚本入口点 ---
main() {
    # 创建一个安全的临时目录，用于存放压缩文件
    TEMP_DIR=$(mktemp -d -t personal_backup_XXXXXX)
    if [ ! -d "$TEMP_DIR" ]; then
        log_and_display "${RED}错误：无法创建临时目录。请检查权限或磁盘空间。${NC}"
        exit 1
    fi
    log_and_display "临时目录已创建: $TEMP_DIR" "${BLUE}"


    load_config # 脚本启动时加载配置

    # 如果直接从 cron 任务调用带有特定参数
    if [[ "$1" == "check_auto_backup" ]]; then
        log_and_display "由 Cron 任务触发自动备份检查。" "${BLUE}"
        check_auto_backup
        exit 0
    fi

    # 在交互模式下检查依赖项 (仅当不是 cron 任务时)
    if ! check_dependencies; then
        log_and_display "${RED}脚本无法运行，因为缺少必要的依赖项。请按照提示安装。${NC}"
        exit 1
    fi

    while true; do
        show_main_menu
        process_menu_choice
    done
}

# 执行主函数
main "$@"
